# System Structure & Program Execution 2

## 1️⃣ 컴퓨 시스템 구조 정리

![image](https://github.com/junseoparkk/til/assets/98972385/93ed0b5e-6df3-4361-9277-ca4355a34a08)

- CPU, Memory 등으로 구성된 컴퓨터를 'Host Computer'라고 하며, 그 외 디스크나 키보드, 마우스 등 입출력 장치를 'I/O Device'라고 한다.
- I/O 디바이스를 관리하기 위해 'Device Controller'가 있고, 데이터를 읽거나 쓰면서 작업 공간인 'Local Buffer'에 저장한다.
- Device Controller가 CPU에게 무언가 전달할 때 'Interrupt'를 걸어서 알려준다.
- CPU는 매 순간 메모리에 올라와있는 인스트럭션을 읽어 실행하게 된다. (4byte)
- 특별한 일이 없다면 CPU는 메모리에 올라와있는 인스트럭션을 순차적으로 실행한다. 하지만 특정 함수를 호출하는 등 메모리 위치를 조정하여 다른 인스트럭션을 실행하기도 한다.
- CPU는 내부 레지스터인 'Program Counter'가 가리키는 메모리 주소의 인스트럭션을 읽고 실행하는 것이다.
- CPU는 인스트럭션을 실행하고 다음 인스트럭션을 실행하기 전에 먼저 인터럽트가 들어와있는지 확인한다. 만약 인터럽트가 있다면 하던 작업을 잠시 멈추고 CPU를 사용하는 주체에 상관 없이 제어권은 운영체제로 넘어간다.
- 운영체제는 인터럽트마다 처리해야될 일들이 커널 함수로 정의되어 있다.
- CPU안의 mode bit에 따라 인스트럭션의 실행 범위가 달라진다. (1: 사용자 프로그램이 CPU를 가짐, 0: 운영체제가 CPU를 가짐 -> 중요한 권한)
- I/O 디바이스에 접근하는 모든 인스트럭션은 mode bit이 0일 때만 가능하다.
- 사용자 프로그램이 운영체제에 작업을 요청할 땐 'system call'을 통해 요청한다. ex) I/O 요청 등
- 시스템 콜을 할 땐 사용자 프로그램이 의도적으로 인터럽트 라인을 세팅한다. CPU는 하던 일을 멈추고 CPU 제어권이 운영체제에 넘어간 뒤 작업을 수행한다.
<br><br>

## 2️⃣ 동기식 입출력과 비동기식 입출력

### 1) 동기식 입출력 (Synchronous I/O)
- I/O 요청 후 입출력 잡업이 완료된 후에야 사용자 프로그램에게 제어가 넘어감. 즉 I/O 작업이 끝난 뒤 데이터를 받아야 다음 작업을 할 수 있음. I/O 작업이 끝날 때까지 기다려야 함.
  - 구현 방법 1
    1. I/O가 끝날 때까지 CPU를 낭비시킴
    2. 매시점 하나의 I/O만 일어날 수 있음 -> 결국 CPU 낭비 + I/O 장치 낭비
  - 구현 방법 2
    1. I/O가 완료될 때까지 해당 프로그램에게서 CPU를 뺴앗음
    2. I/O 처리를 기다리는 줄에 해당 프로그램을 줄 세움
    3. 다른 프로그램에게 CPU를 줌

### 2) 비동기식 입출력 (Asynchronous I/O)
- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 사용자 프로그램에게 즉시 제어가 넘어감. 즉 동기식 입출력과 반대로 I/O 요청을 하고 다음 작업을 수행할 수 있음.

※ 동기식, 비동기식 모두 I/O 작업이 끝났다는 것은 인터럽트를 통해 알려준다.
<br><br>

## 3️⃣ DMA (Direct Memory Access)

### 1) DMA Controller
- 메모리에는 CPU만 접근할 수 있지만, I/O작업이 빈번히 일어날 때 그때마다 인터럽트가 발생하면 비효율적이다. 따라서 작은 작업은 특정 크기의 데이터가 쌓였을 때 DMA가 Local Buffer의 데이터를 가져와 한 번에 인터럽트를 요청한다. -> 인터럽트 빈도 낮아짐 -> CPU 효율 높아짐
- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴
<br><br>

### 2) 서로 다른 I/O 방식
1. I/O를 수행하는 special 인스트럭션에 의해 : 메모리에 접근하는 인스트럭션과 I/O 장치에 접근하는 인스트럭션이 따로 존재
2. Memory Mapped I/O에 의해 : I/O 장치도 메모리 주소에 연장 주소를 붙여서 접근
<br><br>

## 4️⃣ 저장장치 계층 구조

### 1) 메모리 계층

![image](https://github.com/junseoparkk/til/assets/98972385/97f3f475-d10a-4845-b9a5-d5e071fdb862)

- Resisters (레지스터) : CPU 안에 있는 작은 메모리. 휘발성이며 속도가 가장 빠르지만 기억 용량이 가장 작다.
- Cache Memory (캐시 메모리) : L1, L2 캐시를 말한다. 휘발성이며 속도가 빠르지만 기억 용량이 적다. 여기서 캐싱은 재사용을 목적으로 한다.
- Primary Memory (주기억장치) : 컴퓨터 내부에서 CPU가 현재 처리하고 있는 내용을 저장하는 기억장치. CPU에서 직접적인 접근이 가능하며, 비교적 처리 속도가 빠르며 휘발성의 특성을 가진다. 대표적으로 RAM, ROM이 있다. DRAM같은 경우 CPU에서 byte단위로 접근하여 실행 가능하기 때문에 'Executable'이라고도 불리는 것이다. 휘발성이며 속도와 기억 용량 모두 보통이다.
- Secondary Memory (보조기억장치) : 물리적인 디스크가 연결되어 있는 기억장치이다. 주기억장치보다는 느리지만 컴퓨터 전원을 끄더라도 저장된 데이터가 사라지지 않고 영구적으로 남아있다. 대표적으로 HDD, SSD가 있다. 비휘발성이며 속도가 느리지만 기억 용량이 많다.
<br><br>

1. Speed : 메모리 연산 속도를 말한다. 캐싱을 사용하면 연산 속도를 높일 수 있다.
2. Cost : 단위공간당 가격을 말한다. 비교적 가격이 높은 주기억장치는 용량이 적지만, 보조기억장치는 용량이 크다.
3. Volatility : 휘발성 매체는 컴퓨터의 전원이 나가면 데이터가 사라지지만, 비휘발성 매체는 전원이 나가도 데이터가 사라지지 않는다.
<br><br>

### ※ 캐시 (Cache)
캐시는 데이터를 미리 복사해 놓는 임시 저장소이다. 빠른 장치와 느린 장치의 속도 차이로 인해 발행하는 병목 현상을 줄이기 위해 사용된다. 이를 통해 데이터 접근 시간을 단축할 수 있고, 계산 속도를 높일 수 있다. 실제로 메모리와 CPU 사이의 속도 차이가 크기 때문에 중간에 레지스터 계층을 둬서 해결한다. 이렇게 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 한다. 

웹 브라우저에서 사용하는 캐시로는 쿠키, 로컬 스토리지, 세션 스토리지 등이 있고, 데이터베이서에서는 'redis' 를 캐싱 계층으로 두어 성능을 향상시키기도 한다.

- 캐시 히트 : 캐시에서 원하는 데이터를 찾은 것
- 캐시 미스 : 캐시에서 원하는 데이터를 찾지 못해 주 메모리에서 데이터를 찾아오는 것
<br><br>

## 5️⃣ 프로그램의 실행 (메모리 로드)

![image](https://github.com/junseoparkk/til/assets/98972385/a919513d-0e28-4bd1-b7c7-60068a9ef37f)

프로그램은 보통 실행 파일의 형태로 하드디스크와 같은 '파일 시스템(File System)'에 저장 된다. 이를 실행시키면 0번지부터 시작하는 각 프로그램의 독자적인 메모리 주소 공간이 생긴다. 이러한 주소 공간은 code, data, stack 영역으로 이루어져 있으며, '가상 메모리(Virtual memory)'라고 한다.

- code : CPU에서 실행할 기계어 코드를 담고 있다.
- data : 변수, 전역변수 등 프로그램이 사용하는 자료구조를 담고 있다.
- stack : 코드가 함수 구조로 되어있기 때문에 함수를 호출하거나 반환할 때 데이터를 쌓고 꺼내는 역할을 한다.

이러한 독자적인 주소 공간을 '물리적 메모리(Physical memory)'에 올려 실행을 시킨다. 이 때 커널 영역은 컴퓨터를 켜면 메모리에 항상 올라가있지만, 사용자 프로그램은 실행을 할 때 주소 공간이 생겼다가 프로그램을 종료하면 사라진다. 또한 모든 주소 공간을 물리적 메모리에 올리는 것이 아니라 필요한 부분만 올려 메모리 낭비를 방지한다. 경우에 따라 보관해야 하는 주소 공간 중 당장 필요한 것은 물리적 메모리에 올려놓고, 그렇지 않은 것은 'Swap area'에 내려놓는다. 가상 메모리의 stack, data, code는 각각 분리되어 용도에 맞게 메모리에 올라간다.
<br><br>

### 1) 가상 메모리 (Virtual Memory)
가상 메모리는 메모리 관리 기법중 하나로, 컴퓨터가 실제 이용 가능한 메모리 자원을 추상화하는 방법이다. 이때 가상적으로 주어진 주소를 '가상 주소' 혹은 '논리 주소(logical address)'라고 하며, 실제 메모리상에 있는 주소를 '실제 주소' 혹은 '물리 주소(physical address)'라고 한다. 가상 주소는 메모리관리장치인 'MMU(Memory Management Unit)'에 의해 실제 주소로 변환된다.

만약 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생한다. 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것은 '스와핑(swapping)'이라고 한다.
<br><br>

### 2) 커널 주소 공간의 내용

![image](https://github.com/junseoparkk/til/assets/98972385/f4d0266f-30c0-4c0b-a8e1-ceda6cb181cf)

### 1. code
운영체제는 인터럽트가 들어올 때 CPU를 얻게 된다. 이때 어떻게 처리할지에 대한 내용이 함수의 형태로 커널 코드에 구현되어 있을 것이다. 즉, 시스템콜이나 인터럽트 처리를 위한 코드가 포함되어 있다. 또한 운영체제의 목적인 자원을 효율적으로 관리하기 위한 코드, 사용자에게 편리한 서비스를 제공하기 위한 코드가 존재한다.

### 2. data
운영체제가 사용하는 여러 자료구조가 정의되어 있다. 운영체제는 CPU, Memory, Disk 등을 관리하는데, 이를 관리하는 자료구조가 있을 것이다. 또한 운영체제는 여러 프로세스를 관리하는데, 각 프로그램들의 독자적인 주소 공간을 통해 프로그램을 관리하기 위한 자료구조가 정의되어 있다. 이를 'PCB(Process Controller Block)'이라고 하며, 시스템 안의 프로그램을 관리하는 역할을 한다. 프로세스별로 PCB가 하나씩 만들어진다.

### 3. stack

운영체제의 코드는 여러 프로그램들의 요청에 따라 사용될 수 있다. 각각의 프로세스별로 커널 스택이 따로 있는데, 운영체제의 코드는 함수 구조로 되어있기 때문에 요청에 맞는 함수를 호출하고 반환하는 역할을 한다
<br><br>

### 3) 프로그램의 실행

![image](https://github.com/junseoparkk/til/assets/98972385/814718b4-5782-46b9-847e-51cc690786e2)
<br><br>
---
references<br>
KOCW 반효경-Introduction to Operating Systems