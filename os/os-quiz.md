# OS Quiz

## 1️⃣ Disk Management & Scheduling

### 문제 1)
#### `'Sector' 가 무엇인지, 그 중 'Sector 0' 는 무엇인지 작성해주세요.`
- 'Sector'는 디스크 구조에서 Logical Block이 디스크에 매핑된 위치이다.
- 'Sector 0'은 가장 바깥쪽 실린더의 첫 트랙에 있는 첫 섹터를 가리키며, 부팅과 관련된 정보가 저장되어있다.
---

### 문제 2) 
#### `queue에 33, 75, 12, 54, 58, 99, 41와 같은 실린더 위치의 요청이 존재한다고 가정합니다. 디스크 헤드 43번에서 시작한 'SCAN' 알고리즘의 수행 결과를 작성해주세요.`

<img width="500" alt="image" src="https://github.com/junseoparkk/mdn-web-docs/assets/98972385/6e9b46fd-6a25-4b4a-b722-80ce0e683284">
<br><br>

#### 🔎 SCAN Algorithm
- 'SCAN' 알고리즘은 디스크 스케줄링 알고리즘 중 하나로, '엘리베이터 스케줄링'이라고도 불림
- disk arm이 디스크 한쪽 끝에서 다른쪽 끝으로 이동하면서 길목에 있는 모든 요청을 처리함. 
- 다른 한쪽 끝에 도달하면 역방향으로 이동하면서 길목의 모든 요청을 처리하고 반대쪽 끝으로 이동함.

#### 정답
- 만약 왼쪽 방향으로 이동한다고 했을 때 43번에서 시작하므로 `43 -> 41 -> 33 -> 12 -> 54 -> 58 -> 75 -> 99` 순서로 이동
---

### 문제 3)
#### `queue에 33, 75, 12, 54, 58, 99, 41와 같은 실린더 위치의 요청이 존재한다고 가정합니다. 디스크 헤드 43번에서 시작한 'C-SCAN' 알고리즘의 수행 결과를 작성해주세요.`

<img width="500" alt="image" src="https://github.com/junseoparkk/mdn-web-docs/assets/98972385/578e5f42-ba9a-4f0f-84b5-97c1335ae127">
<br>

#### 🔎 C-SCAN Algorithm
- 'C-SCAN' 알고리즘은 디스크 스케줄링 알고리즘 중 하나로, 헤드가 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리
- 다른쪽 끝에 도달했으면 요청을 처리하지 않고 곧바로 출발점으로 다시 이동
- SCAN보다 균일한 대기 시간을 제공

#### 정답
- 만약 오른쪽 방향으로 이동한다고 했을 떄 43번에서 시작하므로 `43 -> 54 -> 58 -> 75 -> 99 -> 12 -> 33 -> 41` 순서로 이동
---

### 문제 4)
#### 디스크 스케줄링 알고리즘 중 'SCAN'이나 'C-SCAN'은 'LOOK'이나 'C-LOOK'에 비해 비효율적인 이유가 무엇인가요?
- LOOK과 C-LOOK은 헤드가 진행하다가 그 방향에 더이상 기다리는 요청이 없다면 헤드 이동 방향을 즉시 반대로 이동하는 메커니즘
- SCAN이나 C-SCAN은 요청이 있으나 없으나 헤드가 디스크 끝에서 끝으로 이동하므로 비효율적임
---

### 문제 5)
#### RAID 의 사용 목적이 무엇인가요?
1. 디스크 처리 속도 향상
    - 여러 디스크에 block의 내용을 분산 저장
    - 병렬적으로 읽어 오는 기법 -> (interleaving, striping)
2. 신뢰성 (reliability) 향상
    - 동일 정보를 여러 디스크에 중복 저장
    - 하나의 디스크가 고장난다면 다른 디스크에서 읽어옴 -> (mirroring, shadowing)
    - 단순 중복 저장이 아니라 일부 디스크에 parity를 저장하여 공간 효율성을 높일 수 있음
---

### 문제 6)
#### 디스크 스케줄링에서 seek time, rotational latency, transfer time은 각각 무엇을 의미하나요?
  - `Seek time` : 헤드를 해당 실린더로 움직이는데 걸리는 시간
  - `Rotational latency` : 헤드가 원하는 섹터에 도달하기까지 걸리는 시간
  - `Transfer time` : 실제 데이터 전송 시간

---

## 2️⃣ 통합 Quiz

### 문제 1) 운영체제의 목적을 컴퓨터 시스템 관점에서 작성해주세요.

#### 1. 컴퓨터 시스템 자원을 효율적으로 관리
- 프로세서, 기억장치, I/O장치 등 하드웨어 자원을 효율적으로 관리. 사용자간 형평성 있는 자원 분배(형평성) + 주어진 자원으로 최대 성능(효율성)
- 사용자 및 운영체제 자신을 보호
- 프로세스, 파일, 메시지 등 소프트웨어 자원을 효율적으로 관리

#### 2. 컴퓨터 시스템을 편리하게 사용할 수 있는 환경 제공
- 동시 사용자/프로그램들이 각각 독립적인 컴퓨터에서 수행되는 것 같은 환경 제공
- 하드웨어를 다루는 복잡한 부분을 운영체제가 대행
---

### 문제 2)현대 운영체제에서 가장 많이 사용하는 처리 방식과 해당 방식을 설명해주세요. (힌트: interactive한 방식)

- 시분할 (time sharing)
    - 대부분 현대의 운영체제, 여러 작업을 수행할 때 컴퓨터 처리 능력을 일정 시간 단위로 분할하여 사용. 일괄처리에 비해 수행 시간이 짧다. -> 'interactive'한 방식 (키보드로 입력하면 결과를 바로 확인) 
---

### 문제 3) 만약 특정 프로그램이 I/O 작업을 요청한다면 컴퓨터 시스템에서 어떤 일이 일어나는지 작성해주세요. (CPU, OS, I/O 컨트롤러, 인터럽트 등의 단어가 들어가야 함)

1. 프로그램은 CPU를 운영체제로 넘긴다.
2. 운영체제는 해당 I/O 컨트롤러에게 작업을 시킴 
3. 요청 작업이 끝나면 I/O 컨트롤러는 CPU에 인터럽트를 건다.
4. 인터럽트가 들어오면 CPU 제어권은 자동으로 운영체제로 넘어간다. 
5. I/O된 값(로컬 버퍼에 있는 값)을 메모리 공간에 복사
6. 프로그램에 다시 CPU를 넘긴다.
---

### 문제 4) 

---

### 문제 5) System call 또는 Interrupt 발생시 항상 Context Switch가 일어날까요? 이유와 예시를 함꼐 적어주세요.

System call 또는 Interrupt 발생시 반드시 Context Switch가 일어나는 것은 아니다. Context Switch는 사용자 프로세스 하나로부터 또 다른 프로세스로 CPU가 넘어가는 것.

- 단순히 아래처럼 CPU 제어권이 사용자 프로세스 -> 운영체제 커널로 넘어가는 경우는 컨텍스트 스위치가 아님
  1. System call : 프로세스가 본인이 필요해서 운영체제에 무언가를 요청할 때
  2. Interrupt : 컨트롤러와 같은 장치가 CPU에게 정보를 전달할 때
<br><br>

![image](https://github.com/junseoparkk/til/assets/98972385/39a65bf6-655d-43db-b4fa-60f26c1d177a)
---

### 문제 6) 스레드가 동료 스레드와 공유하는 부분이 무엇인지 작성하고, 이러한 방법의 장점을 적어주세요.

- Thread가 동료 Thread와 공유하는 부분 (=task)
    - code section
    - data section
    - OS resources

- 멀티 스레드로 구성된 테스크 구조에서는 하나의 서버 스레드가 blocked(waiting) 상태인 동안에도 동일한 테스크 내의 다른 스레드가 실행되어 빠른 처리가 가능
- 동일한 일을 수행하는 멀티 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있음
- 스레드를 사용하면 병렬성을 높일 수 있음
<br><br>
1. 응답성 (Responsiveness)
    - ex) multi-threaded web
      - network 스레드가 block
      - 다른 스레드는 display
2. 자원 공유 (Resource Sharing)
    - 같은 프로세스를 여러 개 생성하기 보단 하나만 생성, CPU 수행 단위만 여러 개를 둠
    - code, data, 각종 자원들은 스레드간 공유 가능 -> 효율적인 자원 사용
3. 경제성 (Economy)
    - 프로세스 생성, CPU 스위칭보다 스레드 생성, 스위칭의 오버헤드가 훨씬 적음
    - 가능하면 같은 작업을 하는 프로세스는 줄여야 함
4. 병렬성
    - 멀티 프로세서 환경 -> 스레드를 각 프로세서에서 효율적으로 실행 가능
---

### 문제 7) 부모 프로세스가 자식 프로세스의 수행을 종료시키는 세 가지 경우를 작성해주세요. (자발적 종료가 아닌 강제 종료)

1. 자식이 할당 자원의 한계치를 넘어선 경우
2. 자식에게 할당된 task가 더 이상 필요하지 않은 경우
3. 부모가 종료 (exit) 하는 경우
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되지 않도록 함
    - 단계적인 종료
---

### 문제 8) 프로세스 시스템 콜 중 'fork()' 와 'exec()' 의 공통점과 차이점이 무엇인가요?


#### `공통점`
- 프로세스 생성: 두 시스템 호출은 새로운 프로세스를 생성
- 운영 체제 기능 사용: 두 호출은 운영 체제의 기능을 사용하여 프로세스를 생성하거나 교체
<br>

#### `차이점`

1. 동작 방식:
   - fork(): 현재 프로세스를 복제하여 새로운 프로세스를 생성합니다. 부모 프로세스와 자식 프로세스가 생성
   - exec(): 현재 프로세스의 메모리 영역을 새로운 프로그램으로 교체하여 새로운 프로세스를 실행. 기존 프로세스는 완전히 새로운 프로그램으로 대체
2. 결과
   - fork(): 부모 프로세스와 자식 프로세스가 독립적으로 실행됩니다. 부모 프로세스는 자식 프로세스의 ID를 받고, 자식 프로세스는 0을 반환
   - exec(): 현재 프로세스는 완전히 새로운 프로그램으로 교체됩니다. 즉, 현재 프로세스는 실행 중인 프로그램을 종료하고, 대신 새로운 프로그램을 실행
3. 프로세스 관계
   - fork(): 부모 프로세스와 자식 프로세스가 생성
   - exec(): 현재 프로세스가 새로운 프로그램으로 대체되므로, 새로운 프로세스는 기존 프로세스와 동일한 것으로 간주됨
---

### 문제 9) 동일한 CPU에서 3개의 작업 A, B, C가 동시에 도착하고, 각각의 실행 시간이 3초, 5초, 2초일 때, 어떤 CPU 스케줄링 알고리즘이 효율적일까요? 이유와 함께 적어주세요.

###  `SJF`
1. SJF (Shortest Job First):
    - 실행 시간이 짧은 작업부터 처리되기 때문에, 각 작업이 대기하는 시간이 최소화됨
    - 주어진 작업 A, B, C의 실행 시간이 각각 3초, 5초, 2초로, 작업 C가 가장 짧은 실행 시간을 가지고 있으므로 SJF에서는 작업 C가 먼저 처리됨. 따라서 평균 대기 시간을 최소화하는 데 가장 효율적일 것이다.
2. FCFS (First-Come, First-Served):
    - FCFS는 먼저 도착한 작업이 먼저 처리되는 알고리즘이기 때문에, 작업 A, B, C 순서대로 처리될 것이다.
    - 따라서 실행 시간이 짧은 작업인 C가 먼저 처리되지 않고, 더 긴 작업인 A, B가 먼저 CPU를 점유하므로, 평균 대기 시간이 증가할 가능성이 있음.
3. RR (Round Robin):
    - RR은 각 작업에 공정한 CPU 시간을 할당하는데, 주어진 상황에서 각 작업의 실행 시간이 다르므로 공정한 시간 할당이 이루어지지 않을 수 있음.
    - 작업의 간격마다 Context Switching이 발생하므로 오버헤드가 발생할 수 있음.
---

### 문제 10) FCFS, Priority Scheduling, RR 알고리즘을 사용할 때 각각 어떤 상황에서 기아 현상이 발생할 수 있나요? 간단하게 적어주세요.

1. FCFS 
    - 먼저 도착한 작업이 먼저 처리되므로, 실행 시간이 긴 작업이 먼저 처리될 경우에 짧은 작업들이 대기할 수 있음
2. Priority Scheduling
    - 우선순위가 낮은 작업이 우선순위가 높은 작업에 밀려 기아 현상이 발생할 수 있음. 만약 우선순위가 낮은 작업이 계속해서 도착한다면, 우선순위가 높은 작업들은 계속해서 뒤로 밀리게 됨.
3. Round Robin (RR)
    - 각 작업에 할당된 시간이 너무 작게 설정되면, 실행 시간이 긴 작업이 계속해서 CPU를 점유하게 되어 기아 현상이 발생할 수 있음. 
    - 예를 들어, 할당된 시간이 짧은 경우 실행 시간이 긴 작업이 여러 번 CPU를 점유하게 되어 다른 작업들이 오랫동안 대기하게  됨.
---

### 문제 11) 'Race Condition'이 무엇이고, 언제 발생할 수 있나요?

- Race Condition (경쟁 상태)
  - 두 개 이상의 스레드나 프로세스가 공유된 자원에 동시에 접근할 때 발생할 수 있음
<br><br>

1. kernel 수행 중 인터럽트가 발생한 경우
2. 프로세스가 시스템 콜을 하여 커널 모드로 수행 중인데 context switch가 일어나는 경우
3. 둘 이상의 스레드나 프로세스가 공유된 변수, 파일, 데이터베이스 레코드 등의 자원에 동시에 접근하는 경우
---

### 문제 12) 'Critical Section'이 무엇인지, 해당 영역의 세 가지 요구 조건은 무엇인지 간단한 설명과 함께 작성해주세요.

- Critical Section (임계 영역)
  - 프로세스 간 공유 자원을 접근하는데 있어 문제가 발생하지 않도록 한 번에 하나의 프로세스 접근을 보장하는 영역
<br><br>
1. 상호 배제
2. 진행
3. 유한 대기
---

### 문제 13) 'Deadlock'과 'Starvation'의 차이가 무엇인가요?

1. 데드락(Deadlock)
   - 데드락은 여러 프로세스나 스레드가 서로가 가지고 있는 자원을 기다리며 무한히 대기하는 상황
   - 두 개 이상의 프로세스나 스레드가 서로가 가지고 있는 자원을 점유한 채로 다른 프로세스나 스레드가 점유하고 있는 자원을 기다리는 상황이며, 이러한 상태에서는 모든 프로세스나 스레드가 대기 상태에 빠져서 더 이상 진행할 수 없게 됨.
2. 기아(Starvation)
   - 기아는 특정 프로세스나 스레드가 원하는 자원에 대한 접근을 영원히 얻지 못하는 상태를 말한다.
   - 한정된 자원이 계속해서 다른 프로세스나 스레드에게 할당되어서 특정 프로세스나 스레드가 무시되거나 우선순위가 떨어져서 자원을 할당받지 못하는 상황
- 데드락은 자원을 얻지 못한 상태에서 상호적으로 대기하는 상황을 가리키고, 기아는 자원을 점유하고 있는 다른 프로세스나 스레드에 의해 계속해서 자원을 얻지 못하는 상황을 가리킴
---

### 문제 14) 'Deadlock'이 발생했을 때 회복하는 방법 두 가지가 무엇인가요?

1. Process termination
   - Deadlock 과 관련된 모든 프로세스를 한꺼번에 죽임
   - Deadlock 이 없어질 때까지 Deadlock 과 관련된 모든 프로세스를 하나씩 죽임
2. Resource Preemption
   - Deadlock 과 관련된 프로세스로부터 자원을 빼앗음
   - 비용을 최소화할 희생 프로세스를 선정
   - safe state 로 롤백하여 프로세스를 재시작하면 deadlock 이 없어질 수 있음
   - Starvation 문제
     - 동일한 프로세스가 계속해서 희생 프로세스로 선정되는 경우
     - cost factor 에 롤백 횟수도 같이 고려해야 함
---

### 문제 15) Dynamic Loading, Dynamic Linking, Overlays가 무엇인지 작성하고 차이점을 적어주세요.

1. Dynamic Loading (동적 적재)
    - 프로그램 실행 중에 필요한 모듈이나 라이브러리를 필요할 때 메모리에 적재하는 기술. 
    - 프로그램 실행 중에 필요한 부분만 메모리에 적재하여 시스템 자원을 절약할 수 있다. 이를 통해 프로그램의 시작 시간을 줄이고 메모리 사용량을 최적화할 수 있습니다.
2. Dynamic Linking (동적 연결)
    - 프로그램 실행 중에 필요한 외부 라이브러리나 모듈을 실행 파일에 포함하지 않고, 실행 중에 동적으로 연결하는 기술 
    - 라이브러리나 모듈이 프로그램 실행 중에 필요한 경우에만 로드되고 링크되어 메모리에 적재됨. 
    - 실행 파일의 크기를 줄이고 여러 프로그램이 동일한 라이브러리를 공유할 수 있음.
3. Overlays (오버레이)
    - 메모리가 제한된 시스템에서 프로그램이 실행될 때 필요한 코드와 데이터를 필요에 따라 메모리에 로드하는 기술. 
    - 큰 프로그램을 작은 메모리에 로드할 때 사용되며, 프로그램의 실행 흐름에 따라 필요한 오버레이를 동적으로 로드하여 실행. 
    - 메모리 사용을 최적화하고 시스템의 성능을 향상시킬 수 있음.
---

### 문제 16) 외부 단편화가 발생할 때 세그멘테이션보다 페이징 기법이 효율적일까요? 그렇다면 이유는 무엇인가요?

- 그렇다. 
- 세그멘테이션은 각각의 세그먼트의 크기가 다르기 때문에 메모리 공간을 효율적으로 사용하지 못할 수 있다. 반면에 페이징은 모든 페이지의 크기가 동일하기 때문에 외부 단편화가 발생하지 않는다.
--- 

### 문제 17) 'Protection bit' 와 'Valid-invalid bit'을 설명해주세요.

1. Protection bit (보호 비트)
    - 페이지 테이블의 항목에 포함된 비트로, 해당 페이지에 대한 접근 권한을 설정하는 역할을 합니다. 읽기, 쓰기, 실행 등의 권한을 제어하여 메모리 보호를 강화
    - 운영 체제는 프로세스가 메모리에 접근할 때 이 비트를 확인하여 올바른 권한을 갖고 있는지를 확인하고, 보안을 유지
2. Valid-invalid bit (유효-무효 비트)
    - 페이지 테이블의 항목에 있는 비트로, 해당 페이지가 현재 메모리에 있는지 여부를 나타냄. 페이지가 유효하면 메모리에 있고, 무효하면 디스크에 있는 것
    - 프로세스가 메모리에 접근하려 할 때, 운영 체제는 먼저 이 비트를 확인하여 페이지가 메모리에 있는지를 판단하고, 페이지 부재를 관리
---

### 문제 18) CPU가 1번 page에 접근을 시도한다면 어떤 일이 벌어질까요?

<img width="600" alt="image" src="https://github.com/junseoparkk/kakao-cloud-school/assets/98972385/d0040a4f-ce50-4f50-a913-41a938a17026">
<br><br>

1. CPU가 1번 page에 접근 시도
2. 주소 변환을 위해 page table 확인 -> 1번 page는 invalid -> 물리 메모리에 없음
3. 해당 page 를 디스크로부터 물리 메모리에 올려야 함 (I/O 작업) -> 사용자 프로세스가 못함
4. invalid page 에 대해 'page fault' 발생 -> CPU는 자동적으로 운영체제로 넘어감
5. 운영체제가 CPU를 통해 page fault난 page를 메모리에 올림
---

### 문제 19) 'Directory'와 'Partition' 의 차이점이 무엇인가요?

- 디렉토리는 파일들을 조직화하고 관리하는 데 사용되는 논리적인 개념이며, 파일 시스템에서 특정 경로에 위치한 파일들을 담고 있다.
- 파티션은 물리적인 저장 장치를 논리적으로 분할하는 것을 의미하며, 각 파티션은 독립적인 파일 시스템이나 운영 체제를 포함하고 있다.
---

### 문제 20) 연속 할당 방법 중 'Indexed Allocation' 의 장점과 단점을 적어주세요.

### 장점

1. 빠른 접근
   - 인덱스 블록을 통해 파일의 블록들을 빠르게 찾을 수 있습니다. 파일의 어떤 블록에도 직접적으로 접근할 수 있으므로 파일 접근이 효율적
2. 파일 크기의 동적 변경
   - 인덱스 블록을 통해 파일의 크기를 동적으로 변경할 수 있습니다. 파일이 커지면 새로운 데이터 블록을 할당하고 인덱스 블록을 업데이트하여 새로운 블록을 참조할 수 있다.
3. 외부 단편화 감소
   - 각 파일에 대한 인덱스 블록을 유지하기 때문에 파일이 여러 개의 물리적인 블록들로 이루어져 있어도, 인덱스 블록을 통해 단일한 파일로 볼 수 있다. 이는 외부 단편화를 줄여준다.

### 단점

1. 인덱스 공간의 낭비
    - 각 파일에 대한 인덱스 블록을 유지하기 때문에, 작은 파일의 경우에도 상당한 양의 공간이 인덱스 블록으로 소비될 수 있습니다. 이는 공간 낭비로 이어질 수 있다.
2. 인덱스 오버헤드
   - 많은 수의 작은 파일이 있는 경우에는 인덱스 블록을 관리하는 데 오버헤드가 발생할 수 있다. 이는 파일 시스템의 성능을 저하시킬 수 있다.
3. 한계점
   - 인덱스 블록의 크기에는 한계가 있으며, 이를 초과하는 크기의 파일은 처리할 수 없다. 이는 대용량 파일의 관리에 어려움을 초래할 수 있다.