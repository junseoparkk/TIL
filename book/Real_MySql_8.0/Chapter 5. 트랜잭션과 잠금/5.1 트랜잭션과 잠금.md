# <font color="#d99694">5.1 트랜잭션</font>

- 트랜잭션을 지원하지 않는 **MyISAM** vs 트랜잭션을 지원하는 **InnoDB** 처리 방식

## 5.1.1 MySQL 에서의 트랜잭션

### 트랜잭션 (Transaction)

- DBMS (데이터베이스 관리 시스템) 에서 하나의 논리적인 작업 단위를 구성하는 일련의 연산을 의미
- 데이터베이스의 일관성 유지를 위해 필요한 작업들을 한 묶음으로 다룸
- 하나의 논리적인 작업 셋에 쿼리 갯수와 상관 없이 논리적인 작업 셋이 100% 적용 or 아무것도 적용되지 않음을 보장해 주는 것

### 예제

##### 1) MyISAM

```mysql
CREATE TABLE tab_myisam (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE = MyISAM;
INSERT INTO tab_myisam (fdpk) VALUES (3);
```

##### 2) InnoDB

```mysql
CREATE TABLE tab_innodb (fdpk INT NOT NULL, PRIMARY KEY (fdpk)) ENGINE = INNODB;
INSERT INTO tab_innodb (fdpk) VALUES (3);
```

- 테스트용 테이블에 각각 레코드를 1건씩 저장
- `AUTO-COMMIT` 모드에서 아래 쿼리를 실행

##### 3) 결과

```mysql
--- // AUTO-COMMIT 활성화
SET autocommit = ON;

INSERT INTO tab_myisam (fdpk) VALUES (1),(2),(3);
INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);

--- 중복 데이터 삽입
INSERT INTO tab_myisam (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'
```

![[Pasted image 20240531173331.png]]

- 두 INSERT 문장 모두 PK 중복 오류로 쿼리 실패
- `MyISAM` : 1, 2, 3 모두 남아 있음
- `InnoDB` : 3 만 남아 있음

##### 4) Why?

- InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원래 상태로 만든다는 트랜잭션의 원칙을 따름
- 따라서 `INSERT` 문장을 실행하기 전 상태로 그대로 복구함
- `MyISAM` 테이블에서 발생하는 이러한 현상은 **부분 업데이트 (Partial Update)** 라고 함
  - 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는 어려운 문제를 만들어 냄

## 5.1.2 주의사항

- 트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소의 레코드에만 적용하는 것이 좋음
  - 프로그램 코드에서 트랜잭션 범위를 최소화하라는 의미
  -

### 예시 (초기 흐름)

- 사용자가 게시판 게시글 작성 후 저장 버튼을 클릭할 때 서버에서 처리하는 흐름

1. 처리 시작
   - 데이터베이스 커넥션 생성
   - 트랜잭션 시작
2. 사용자 로그인 여부 확인
3. 사용자 글쓰기 내용 오류 여부 확인
4. 첨부 파일 확인 및 저장
5. 사용자 입력 내용을 DBMS 에 저장
6. 첨부 파일 정보를 DBMS 에 저장
7. 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8. 게시글 등록 알림 메일 발송
9. 알림 메일 발송 이력을 DBMS 에 저장
   - 트랜잭션 종료 (COMMIT)
   - 데이터베이스 커넥션 반납
10. 처리 완료

#### 트랜잭션 처리에 안좋은 영향을 미치는 부분

##### 1) 데이터베이스 커넥션 생성

- 1, 2번 과정 사이에 커넥션을 생성, 트랜잭션을 시작함
- 9, 10번 과정 사이에 트랜잭션을 종료, 커넥션을 반납
- 그러나 실제로 DBMS 에 데이터를 저장하는 작업은 5번 과정부터 시작
- 2, 3, 4번 과정이 빨리 끝난다고 하더라도 트랜잭션에 포함시킬 필요가 없음
- 커넥션의 개수가 제한적이기 때문에 프로그램의 커넥션 소유 시간이 길어질수록 여유 커넥션 개수가 줄어듦

##### 2) 원격 서버와의 통신

- 8번 작업에서 메일 전송, FTP 파일 전송 등 네트워크를 통한 원격 서버 통신 작업은 DBMS 트랜잭션 내에서 제거하는 것이 좋음
- 프로그램이 실행되는 동안 메일 서버와 통신 불가능한 상황이 발생한다면, 웹 서버 + DBMS 서버까지 위험해짐

##### 3) 트랜잭션 묶음

- 위 과정에선 DBMS 작업이 크게 4개 존재
- 사용자 입력 정보를 저장하는 5, 6번 작업은 반드시 하나의 트랜잭션으로 묶여야 함
- 7번 작업은 단순 조회이므로 트랜잭션에 포함될 필요 X

### 예시 (개선된 흐름)

1. 처리 시작
2. 사용자 로그인 여부 확인
3. 사용자 글쓰기 내용 오류 여부 확인
4. 첨부 파일 확인 및 저장
   - 데이터베이스 커넥션 생성 or 커넥션 풀에서 가져오기
   - 트랜잭션 시작
5. 사용자 입력 내용을 DBMS 에 저장
6. 첨부 파일 정보를 DBMS 에 저장
   - 트랜잭션 종료 (COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS 에서 조회
8. 게시글 등록 알림 메일 발송
   - 트랜잭션 시작
9. 알림 메일 발송 이력을 DBMS 에 저장
   - 트랜잭션 종료 (COMMIT)
   - 데이터베이스 커넥션 반납
10. 처리 완료

---

# <font color="#d99694">5.2 MySQL 엔진의 잠금</font>

### MySQL 엔진 레벨 VS 스토리지 엔진 레벨

#### 1) MySQL 엔진

- MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미침
- 다양항 Lock 지원
  - 테이블 데이터 동기화를 위한 **Table Lock**
  - 테이블의 구조를 잠그는 **Metadata Lock**
  - 사용자의 필요에 맞게 사용 가능한 **Named Lock**

#### 2) 스토리지 엔진

- 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음

## 5.2.1 글로벌 락 (Global Lock)

### 설명

- `FLUSH TABLES WITH READ LOCK` 명령을 통해 획득 가능
- MySQL 에서 제공하는 잠금 중 가장 큰 범위
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 `SELECT` 를 제외한 대부분의 DDL / DML 문장을 실행할 경우, 글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남음
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체, 작업 대상 테이블 or 데이터베이스가 다르더라도 동일하게 영향을 미침
- 여러 데이터베이스에 존재하는 **MyISAM** 이나 **MEMORY** 테이블에 대해 `mysqldump` 로 일관된 백업이 필요한 경우 글로벌 락을 사용해야 함

### 백업 락 (Backup Lock)

#### 1) 백업 락 이란?

- 글로벌 락은 MySQL 서버의 모든 변경 작업을 멈춤
- MySQL 8.0 부터는 **InnoDB**가 기본 스토리지 엔진으로 채택, 이는 트랜잭션을 지원
- 따라서 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요 X
- 조금 더 가벼운 글로벌 락의 필요성 -> `Xtrabackup` 이나 `Enterprise Backup` 과 같은 백업 락 도입

```mysql
LOCK INSTANCE FOR BACKUP;
-- // 백업 실행
UNLOCK INSTANCE;
```

특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블 스키마나 사용자 인증 관련 정보 변경 불가능

- 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
- `REPAIR TABLE` , `OPTIMIZE TABLE` 명령
- 사용자 관리 및 비밀번호 변경

#### 2) 백업 락의 역할

- 백업 락은 일반적인 테이블의 데이터 변경은 허용
- MySQL 서버의 일반적인 구성은 **소스 서버(Source Server)** + **레플리카 서버(Replica Server)**, 백업은 레플리카 서버에서 실행됨
- 백업이 글로벌 락을 획득하면 복제는 백업 시간만큼 지연됨
- 위에서 언급한 백업 락은 DDL 명령 하나로 인해 백업이 실패하면 다시 해당 시간을 들여 백업을 실행해야 함
- 결국 정상적으로 복제는 실행되지만, 백업의 실패를 막기 위한 DDL 명령이 실행되면 복제를 일시 중지하는 역할

## 5.2.2 테이블 락 (Table Lock)

### 설명

- 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 **특정 테이블의 락** 획득 가능

#### 명시적 테이블 락

- `LOCK TABLES table_name [ READ | WRITE ]` 명령으로 테이블 락 획득
- `UNLOCK TABLES` 명령으로 잠금 반납 (해제)
- 명시적인 테이블 락도 특별한 상황이 아니라면 사용할 필요가 거의 없음 (온라인에 상당한 영향을 미침)
- **MyISAM** 뿐만 아니라, **InnoDB** 스토리지 엔진을 사용하는 테이블 동일하게 설정 가능

#### 묵시적 테이블 락

- **MyISAM** 이나 **MEMORY** 테이블에 데이터 변경 쿼리를 실행하면 발생
  - MySQL 서버가 데이터 변경 테이블에 잠금을 설정하고 데이터 변경 후, 즉시 잠금을 해제하는 형태로 사용
  - 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제
- **InnoDB** 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공
  - 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되진 않음
  - 테이블 락이 설정되긴 하지만 대부분 `데이터 변경 쿼리(DML)` 에서는 무시, `스키마 변경 쿼리(DDL)` 경우에만 영향을 미침

## 5.2.3 네임드 락 (Named Lock)

### 설명

- `GET_LOCK()` 함수를 통해 **임의의 문자열에 대한 락** 설정 가능
  - 네임드 락의 대상이 테이블이나 레코드, 또는 `AUTO_INCREMENT` 같은 데이터베이스 객체 X
  - 단순히 사용자 지정 문자열(String)에 대해 획득하고 반납(해제)하는 잠금
- 자주 사용되지는 않음 (여러 클라이언트가 상호 동기화를 처리할 때 사용)
- 많은 레코드에 대해 `복잡한 요건으로 레코드를 변경하는 트랜잭션` 에서 유용하게 사용 가능
  - 배치 프로그램처럼 한 번에 많은 레코드를 변경하는 쿼리 : 데드락의 원인
  - 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류하여 네임드 락을 걸어 해결 가능
- MySQL 8.0 부터는 네임드 락을 중첩해서 사용 가능, 현재 세션에서 획득한 네임드 락을 한 번에 모두 해제하는 기능도 추가됨

## 5.2.4 메타데이터 락 (Metadata Lock)

### 설명

- 데이터베이스 객체 (Table, View 등) 이름이나 구조를 변경하는 경우 획득하는 잠금
- 명시적으로 획득 / 해제할 수는 없음.
  - `RENAME TABLE tab_a TO tab_b` 처럼 테이블명을 변경하는 경우 자동으로 획득하는 잠금
  - `RENAME` 명령은 원본 이름, 변경될 이름 두 개 모두 한꺼번에 잠금 설정
- 실시간으로 테이블을 바꿔야 하는 요건이 배치 프로그램에서 자주 발생

---

# <font color="#d99694">5.3 InnoDB 스토리지 엔진 잠금</font>

- **InnoDB** 스토리지 엔진은 MySQL이 제공하는 잠금과는 별개로, 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재
- 레코드 기반의 잠금 방식 때문에 **MyISAM** 보다는 훨씬 뛰어난 동시성 처리 제공
- 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 명령어로 접근하기 힘듦
- 최근 버전에서는 InnoDB 트랜잭션과 잠금, 잠금 대기 중인 트랜잭션 목록 조회 등 기능 도입

## 5.3.1 InnoDB 스토리지 엔진의 잠금

![[Pasted image 20240531192904.png]]

### 설명

- 레코드 기반의 잠금 기능 제공, 잠금 정보가 상당히 작은 공간으로 관리
  - 레코드 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우는 없음
  - 일반 상용 DBMS 와는 다르게 레코드 락뿐만 아니라, 레코드와 레코드 사이의 간격을 잠그는 **갭(Gap) 락** 존재
- 보조 인덱스를 이용한 변경 작업은 **넥스트 키 락(Next Key Lock)** 또는 **갭 락(Gap Lock)** 사용
- PK 또는 유니크 인덱스에 의한 변경 작업은 갭에 대해서는 잠그지 않고, 레코드 자체만 락

### 레코드 락 (Record Lock)

- 레코드 자체만을 잠그는 것, 다른 상용 DBMS 의 레코드 락과 동일한 역할
- InnoDB 스토리지 엔진은 레코드 자체가 아니라, 인덱스의 레코드를 잠금
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정

### 갭 락 (Gap Lock)

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것
- 레코드와 레코드 사이의 간력에 새로운 레코드가 생성되는 것을 제어하는 역할
- 갭 락 자체보다는 넥스트 키 락의 일부로 주로 사용됨

### 넥스트 키 락 (Next Key Lock)

- 레코드 락 + 갭 락 을 합쳐 놓은 형태의 잠금
- `STATEMENT` 포맷의 바이너리 로그를 사용하는 MySQL 서버는 `REPEATABLE READ` 격리 수준을 사용해야 함
- `innodb_locks_unsafe_for_binlog` 시스템 변수가 비활성화되면(0으로 설정), 변경을 위해 검색하는 레코드에는 넥스트 키 락 방식으로 잠금이 걸림
- 갭 락, 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장해주는 것이 주 목적

### 자동 증가 락 (Auto Increment Lock)

- MySQL 에서는 자동 증가하는 숫자 값 추출을 위해 `AUTO_INCREMENT` 라는 컬럼 속성 제공
- `AUTO_INCREMENT` 컬럼이 사용된 테이블에 동시에 여러 레코드가 삽입되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야 함
  - InnoDB 스토리지 엔진에서는 내부적으로 `AUTO_INCREMENT` 락 이라고 하는 테이블 수준의 잠금 사용
- `INSERT` 와 `REPLACE` 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에서만 필요함
- InnoDB의 다른 잠금과는 달리 트랜잭션과 관계없이 `INSERT` 나 `REPLACE` 문장에서 `AUTO_INCREMENT` 값을 가져오는 순간만 락이 걸렸다가 즉시 해제

## 5.3.2 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아니 **인덱스를 잠그는 방식**으로 처리됨
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락을 걸어야 함

![[Pasted image 20240531194510.png]]

- 만약 해당 테이블에 인덱스가 하나도 없다면, 테이블을 풀 스캔하면서 `UPDATE` 작업 진행
- 해당 과정에서 테이블에 있는 30여만 건의 모든 레코드를 잠그게 됨
- MySQL의 InnoDB에서 인덱스 설계가 중요한 이유

## 5.3.3 레코드 수준의 잠금 확인 및 해제

# <font color="#d99694">5.4 MySQL 의 격리 수준</font>

### 트랜잭션의 격리 수준 (Isolation Level)

- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 . 수있게 허용할지 말지를 경정하는 것
- 크게 `READ UNCOMMITTED` , `READ COMMITTED` , `REPEATABLE READ` , `SERIALIZABLE` 의 4가지로 나뉨
- 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지며, 동시 처리 성능도 떨어지는 것이 일반적

![[Pasted image 20240531195152.png]]

- 일반적인 온라인 서비스 용도의 데이터베이스는 `READ COMMITTED` 와 `REPEATABLE READ` 중 하나를 사용
- **Oracle** 같은 DBMS 에서는 주로 `READ COMMITTED` 수준을 많이 사용
- **MySQL** 에서는 `REPEATABLE READ` 를 주로 사용

## 5.4.1 READ UNCOMMITTED

![[Pasted image 20240531195421.png]]

### 설명

- `READ UNCOMMITTED` 격리 수준에서는 각 트랜잭션의 변경 내용이 `COMMIT` 이나 `ROLLBACK` 여부에 상관 없이 다른 트랜잭션에서 보임
- 위 그림에서 사용자 A는 `INSERT(sara)` 수행, 사용자 B가 변경된 내용을 커밋하기도 전에 해당 사원을 검색. 하지만 사용자 B는 사용자 A가 추가한 사원의 정보를 커밋되지 않은 상태에서도 조회 가능
- 문제는 사용자 A가 처리 도중 문제가 발생해 추가한 내용을 롤백하더라도 사용자 B는 정상적인 데이터라고 판단하여 계속 처리하게 됨

- **더티 리드(Dirty Read)** : 어떤 트랜잭션에서 처리한 작업이 완료되기 이전에 다른 트랜잭션에서 볼 수 있는 현상
- 더티 리드가 허용되는 격리 수준이 `READ UNCOMMITTED`

## 5.4.2 READ COMMITTED

![[Pasted image 20240531200549.png]]

### 설명

- Oracle DBMS 에서 기본적으로 사용되는 격리 수준, 온라인 서비스에서 가장 많이 선택됨
- 더티 리드 같은 현상은 발생하지 않음 (어떤 트랜잭션이 데이터를 변경해도 `COMMIT` 이 완료된 데이터만 다른 트랜잭션에서 조회 가능)

- 위 그림에서 사용자 A는 `Lara` 를 `Toto` 로 변경, 이 때 `employees` 테이블에 변경 사항이 즉시 기록되며 이전 값인 `Lara` 는 언두 영역으로 백업됨
- 사용자 A가 커밋을 수행하기 전 사용자 B가 해당 데이터를 조회하면 `Lara` 로 조회됨 (언두 영역이 아닌 백업된 레코드에서 가져옴)
- `READ COMMITTED` 격리 수준에서는 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 변경 내역 조회 불가능
- `NON-REPEATABLE READ` 라는 부정합의 문제가 있음

## 5.4.3 REPEATABLE READ

### 설명

- MySQL의 InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- 바이너리 로그를 가진 MySQL 서버에서는 최소 `REPEATABLE RAD` 격리 수준 이상을 사용해야 함
- **MVCC (Multi Version Concurrency Control)** : 트랜잭션이 롤백될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경
- `REPEATABLE READ` 는 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용, 동일 트랜잭션 내에서는 동일 결과를 보여줄 . 수있게 보장
- **PHANTOM READ** : 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안보였다 하는 현상

## 5.4.4 SERIALIZABLE

### 설명

- 가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준
- 동시 처리 성능도 다른 트랜잭션 격시 수준보다 떨어짐
- InnoDB 테이블에서 순수 `SELECT` 작업은 아무런 레코드 잠금도 설정하지 않고 실행됨
- 트랜잭션 격리 수준이 `SERIALIZABLE` 로 설정되면 읽기 작업도 공유 잠금을 획득해야함, 동시에 다른 트랜잭션은 해당 레코드 변경 불가능
- 일반적인 DBMS에서 일어나는 **팬텀 리드** 문제 발생X
- 이미 갭 락과 넥스트 키 락때문에 `REPEATABLE` 격리 수준에서도 이미 팬텀 리드 발생 X 이므로 굳이 해당 격리 수준을 사용할 필요성은 없음
