# 4.2 InnoDB Storage Engine Architecture - 1

![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/00c7eeca-416a-4c71-a3bb-e588956032c2)

- InnoDB 는 MySQL에서 가장 많이 사용되는 스토리지 엔진
- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공
  - 높은 동시성 처리 가능
  - 안정적이며 성능이 뛰어남
    <br><br>

## 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장 (PK 값의 순서대로 디스크에 저장)
- 모든 세컨더리 인덱스는 레코드 주소 대신 PK 값을 논리적인 주소로 사용
- 쿼리 실행 계획에서 다른 보조 인덱스에 비해 PK 비중이 높게 설정
- MyISAM 스토리지 엔진에서는 클러스터링 키 미지원
  - PK 는 유니크 제약을 가진 세컨더리 인덱스
  - 모든 인덱스는 물리적인 레코드 주소 값 (ROWID)을 가짐
    <br><br>

## 4.2.2 외래 키 지원

- 외래 키 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능 (MyISAM 이나 MEMORY 테이블에선 사용 불가)
- FK는 부모 및 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요, 변경 시 반드시 부모 및 자식 테이블 데이터 존재 여부 체크 작업 필요
  - 잠금이 여러 테이블로 전파 => 데드락 발생 가능성 증가
- FK 가 복잡하게 얽힌 경우 수동으로 데이터를 적재하거나 스키마 변경 등 관리 작업 실패 가능
  - `foreign_key_checks` 시스템 변수를 `OFF` 로 설정하면 FK 관계에 대한 체크 작업을 일시적으로 멈출 수 있음
    <br><br>

## 4.2.3 MVCC (Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것
  - `언두 로그(Undo log)` 를 통해 구현
- 멀티 버전 => 하나의 레코드에 대해 여러 개 버전이 동시에 관리된다는 의미

### 🔎 InnoDB 스토리지 사용 테이블 데이터 변경 처리

```sql
CREATE TABLE member {
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(20) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
};

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

COMMIT;
```

- 위 명령어를 입력했을 때 데이터베이스의 상태
  <br>
  ![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/a8631013-da65-47d5-a9bc-81553ab9460e)
  <br><br>

- 업데이트 쿼리

```sql
UPDATE member SET m_area='경기' WHERE m_id=12;
```

![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/c5ba6df2-f3c4-406b-8037-52f5b5f852dc)

- COMMIT 이나 ROLLBACK 되지 않은 상태에서 다른 사용자가 `SELECT` 쿼리로 작업 중인 레코드를 조회한다면?
  - MySQL 서버의 시스템 변수에 설정된 격리 수준에 따라 결과가 달라짐
    1. 격리 수준이 `READ_UNCOMMITTED` 인 경우 : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환
    2. 격리 수준이 `READ_COMMITTED` 나 그 이상인 경우 : InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환
- 위 과정을 DBMS에서 `MVCC`라고 표현
  - 여러 개의 버전이 유지되며, 필요에 따라, 상황에 따라 보여지는 데이터가 달라지는 구조
    <br><br>

## 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 통해 잠금을 걸지 않고 읽기 작업을 수행
- 다른 트랜잭션이 가진 잠금을 기다리지 않고 읽기 작업 가능

### 💡 예시

![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/1622cc7f-101b-4fac-9990-a5fd4557ab4c)

- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도, 해당 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음 => `잠금 없는 일관된 읽기`
- InnoDB 에선 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용
  <br><br>

## 4.2.5 자동 데드락 감지

- 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 `그래프(Wait-for List)`형태로 관리
- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어, 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그중 하나를 강제 종료
  - 트랜잭션 종료 순서를 판단하는 기준 : 트랜잭션의 언두 로그 양
  - 일반적으로 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 됨 - 롤백을 해도 언두 처리를 해야 할 내용이 적다는 의미 => 서버 부하도 덜 유발함
    <br><br>

### 🔎 데드락 감지 스레드 작업 성능

- 일반적인 서비스에선 데드락 감지 스레드가 트랜잭션 잠금 목록을 검사해 데드락을 찾는 작업은 크게 부담되지 않음
- 동시 처리 스레드가 매우 많아지거나, 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐
  - 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음
  - 데드락 감지 스레드가 느려지면, 서비스 쿼리를 처리하는 스레드의 작업도 대기하게 됨 => 악영향
- 이런 문제를 해결하기 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수 제거
  - OFF 로 설정하면 데드락 감지 스레드 작동 X
  - 데드락 감지 스레드가 작동하지 않으면 InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 데드락 상황이 발생해도 중재 기능이 없어 무한정 대기

## 4.2.6 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘 탑재
  - MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나, 일부 디스크에만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행 됨
    <br><br>

### 🔎 디스크나 서버 HW 이슈로 자동 복구를 못할 경우

- MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정하여 MySQL 서버를 시작해야 함
- 서버 시작히 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 함
  - InnoDB 로그 파일이 손상됐다면 6으로 설정하고 서버 가동
  - InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 서버 가동
  - 어떤 부분이 문제인지 알 수 없다면 시스템 변수 값을 1~6까지 변경하면서 서버를 재시작 해 본다.
    <br><br>

### 🔎 `inoodb_force_recovery` 설정 값

- `1 (SRV_FORCE_IGNORE_CORRUPT)`
  - InnoDB 테이블 스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 서버를 시작
  - mysqldump 프로그램 등을 통해 덤프해서 DB를 다시 구축하는 것이 좋다
- `2 (SRV_FORCE_NO_BACKGROUND)`
  - 백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 서브를 시작
  - 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 해당 모드로 복구
- `3 (SRV_FORCE_NO_TRX_UNDO)`
  - InnoDB에서 트랜잭션 실행시 롤백에 대비해 변경 전 데이터를 언두 영역에 기록
  - 커밋되지 않고 종료된 트랜잭션은 계쏙 그 상태로 남아 있게 서버를 시작하는 모드
  - 우선 서버가 시작되면 mysqldump 를 이용해 데이터를 백업하여 다시 DB를 추축하는 것이 좋다
- `4 (SRV_FORCE_NO_IBUF_MERGE)`
  - InnoDB 는 INSERT, UPDATE, DELETE 등의 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 다르게 처리
    - 즉시 처리
    - 인서트 버퍼에 저장해두고 나중에 처리
  - 인서트 버퍼에 기록된 내용은 언제 데이터 파일에 병합될지 알 수 없음 (MySQL을 종료해도 병합되지 않을 수 있음) => 인서트 버퍼 손상시 서버 시작 불가능
  - 해당 모드는 InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 서버를 실행함
- `5 (SRV_FORCE_NO_UNDO_LOG_SCAN)`
  - MySQL 서버가 장애나 정상 종료되는 시점에 진행 중인 트랜잭션이 있다면 해당 커넥션을 강제로 끊고, 별도의 정리 작업 없이 종료
  - 다시 시작하면 언두 레코드를 이용해 데이터 페이지를 복구하고, 리두 로그를 적용해 종료 및 장애 발생 시점의 상태를 재현함
  - 마지막으로 커밋되지 않은 트랜잭션에서 변경한 작업은 모두 롤백 처리 함
  - InnoDB의 언두 로그를 사용할 수 없다면 에러가 발생하며 서버 시작 불가능
  - 해당 모드는 언두 로그를 모두 무시하고 MySQL을 시작
    - 해당 모드로 복구되면 서버 종료 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리 (실제로 잘못된 데이터가 DB에 남는 것)
    - mysqldump 를 이용해 데이터를 백업, DB를 새로 구축해야 함
- `6 (SRV_FORCE_NO_LOG_REDO)`
  - InnoDB 스토리지 엔진의 리두 로그가 손상되면 서버 시작 불가능
  - 해당 복구 모드로 시작하면 리두 로그를 모두 무시하고 서버 시작
  - 마지막 체크포인트 시점의 데이터만 남게 됨 - 기존 InnoDB의 리두 로그는 모두 삭제하고 서버를 시작하는 것이 좋음 - mysqldump를 이용해 데이터를 모두 백업하고 새로운 서버를 구축하는 것이 좋음
    <br><br>

## 4.2.7 InnoDB 버퍼 풀 (Buffer Pool)

- InnoDB 스토리지 엔진에서 가장 핵심이 되는 부분으로, 디스크 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 `버퍼` 역할도 같이 함
- 일반적인 애플리케이션의 INSERT, UPDATE, DELETE 등 데이터 변경 쿼리는 랜덤한 디스크 작업을 발생시키는데, 이렇게 변경된 데이터를 모아서 처리하면 디스크 작업 횟수를 줄일 수 있음
  <br><br>

### 1) 버퍼 풀의 크기 설정

- InnoDB 버퍼 풀의 크기를 설정할 때 운영체제와 각 클라이언트 스레드가 사용할 메모리도 충분히 고려해야 함
- MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 필요 X
  <br><br>

#### 🔎 Record Buffer

- `Record Buffer` : 각 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 떄 버퍼로 사용하는 공간
- 커넥션이 많고 사용하는 테이블이 많다면 레코드 버퍼 용도로 사용되는 메모리 공간이 많이 필요할 수도 있음
- MySQL 서버가 사용하는 레코드 버퍼 공간은 별도로 설정 불가
  - 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블의 개수에 따라서 결정됨
  - 해당 버퍼 공간은 해제되기도 하므로 필요한 메모리 공간의 크기를 정확히 계산할 수 없음

#### 🔎 버퍼 풀 크기 조정 방법

- MySQL 5.7 버전 이상부터 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있도록 개선
  - 가능하면 버퍼 풀의 크기를 적절히 작은 값으로 설정하여 상황에 따라 조금씩 증가시키는 방법이 최적
- `innodb_buffer_pool_size` 시스템 변수를 통해 크기를 설정하고, 버퍼풀의 크기를 동적으로 확장 가능
  - 해당 작업은 크리티컬한 변경이므로 가능하면 MySQL 서버가 한가한 시점에 진행해야 함
  - 버퍼 풀의 크기를 더 크게 변경하는 작업은 비교적 시스템 영향도가 낮음
  - 버퍼 풀의 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 가능하면 X

<br>

1. 운영체제 전체 메모리 공간이 `8GB 미만`인 경우
   - 50% 정도만 InnoDB 버퍼 풀로 설정, 나머지 메모리 공간은 MySQL 서버와 운영체제, 다른 프로그램이 사용할 수 있는 공간 확보
2. 운영체제 전체 메모리 공간이 `8GB 이상`인 경우
   - InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올려가며 최적점 찾음
3. 운영체제 전체 메모리 공간이 `50GB 이상`인 경우
   - 대략 15GB ~ 30GB 정도를 운영체제와 다른 응용 프로그램을 위해 남겨두고, 나머지를 InnoDB 버퍼 풀로 할당

#### 🔎 InnoDB Buffer Pool Instance

- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 내부 잠금 경합을 많이 유발해왔음
  - 이를 줄이기 위해 버퍼 풀을 여러 개로 쪼개어 관리할 수 있도록 개선
  - 개별 버퍼 풀 전체를 관리하는 잠금 자체도 경합이 분산되는 효과
  - `innodb_buffer_pool_instances` 시스템 변수를 이용해 버퍼 풀을 분리하여 관리할 수 있고, 각 버퍼 풀을 '버퍼 풀 인스턴스' 라고 표현
- 기본적인 버퍼 풀 인스턴스 개수는 8개로 초기화
  - 버퍼 풀을 위한 메모리가 1GB 미만인 경우, 버퍼 풀 인스턴스는 1개만 생성됨
  - 버퍼 풀을 위한 메모리가 40GB 이하인 경우, 기본값인 8을 유지
  - 버퍼 풀을 위한 메모리가 큰 경우, 인스턴스당 5GB 정도가 되게 인스턴스 개수를 설정하는 것이 좋음
    <br><br>

### 2) 버퍼 풀의 구조

#### InnoDB 스토리지 엔진의 버퍼 풀

- 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
- 버퍼 풀의 페이지 크기 조각을 관리하기 위해 InnoDB 스토리지 엔진은 크게 3개의 자료 구조를 관리 1. LRU(Least Recently Used) List 2. Flucsh List 3. Free List
  <br><br>

1. `Free List`
   - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
   - 사용자 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우에 사용
2. `LRU List`
   - LRU + MRU(Most Recently Used) List 결합된 형태
   - 관리 목적은 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하는 것

#### 🔎 InnoDB 스토리지 엔진에서 데이터를 찾는 과정

1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 존재하는지 검사
   - InnoDB 어댑티브 해시 인덱스를 이용해 페이지 검색
   - 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지 검색
   - 버퍼 풀에 이미 데이터 페이지가 있었다면, 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고, 해당 페이지는 버퍼 풀에서 제거
   - 만약 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고, MRU의 헤더 부분으로 옮겨짐
5. 필요한 데이터가 자주 접근되었다면 해당 페이지 인덱스 키를 어댑티브 해시 인덱스에 추가
   <br><br>

### 3) 버퍼 풀과 리두 로그

- InnoDB 버퍼 풀은 DB 서버의 성능 향상을 위해 `데이터 캐시` 와 `쓰기 버퍼링` 이라는 두 가지 용도가 존재
  1. 버퍼 풀의 메모리 공간만 늘리는 것은 데이터 캐시 기능만 향상시키는 것
  2. 쓰기 버퍼링 기능까지 향상시키러면 InnoDB 버퍼 풀과 리두 로그와의 관계를 이해해야 함

#### 🔎 버퍼 풀과 리두 로그와의 관계

![image](https://github.com/100-hours-a-week/5-jun2-java-casino/assets/98972385/f8ecca35-8098-47ba-8fcf-13d10174ec35)

- InnoDB 버퍼 풀이 가지는 페이지
  1. `클린 페이지(Clean Page)` : 디스크에서 읽은 상태로 전혀 변경되지 않은 페이지
  2. `더티 페이지(Dirty Page)` : INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 페이지
- 더티 페이지는 버퍼 풀에 항상 머무르는가?
  - 아니다. InnoDB 스토리지 엔진에서 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 다시 새로운 엔트리로 덮어 씀
  - 따라서 전체 리두 로그 파일중 재사용 가능한 공간 vs 당장 재사용 불가능한 공간을 구분해서 관리해야 함
  - 이 때 재사용 불가능한 공간을 `활성 리두 로그(Active Redo Log)` 라고 함. 위 그림에서 화살표를 가진 엔트리가 활성 리두 공간
    <br><br>

#### 🔎 LSN (Log Sequence Number)

- 리두 로그 파일 공간은 계속 순환되어 재사용되지만, 매번 기록될 때마다 로그 포지션은 계송 증가된 값을 가짐. 이 값이 `LSN`
- InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생 -> 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화
- 이 떄 발생한 체크포인트 중 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 됨 (활성 리두 공간의 마지막은 계속 증가해서 체크포인트와는 무관)
- `체크포인트 에이지(Checkpoint Age)` : 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이 -> `활성 리두 공간의 크기` 를 말함

#### 🔎 예제

1. InnoDB 버퍼 풀 : 100GB, 리두 로그 파일 전체 크기 : 100MB 인 경우
2. InnoDB 버퍼 풀 : 100MB, 리두 로그 파일 전체 크기는 100GB 인 경우

- 1번의 경우 로그 파일 크기가 100MB이므로 체크포인트 에이지도 최대 100MB만 허용
  - 버퍼 풀의 크기는 매우 크지만, 실제 쓰기 버퍼링을 위한 효과는 거의 못 보는 상황
- 2번의 경우 대략 400GB 정도의 더티 페이지를 가질 수 있지만, 최대 허용 가능한 더티 페이지는 100MB

#### 결론

- `둘 다 좋은 설정이 아니다.`
- 1번은 잘못된 설정
- 2번은 급작스러운 디스크 쓰기가 발생할 가능성이 높음. 버퍼 풀에 더티 페이지의 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지는 상황이 오면, InnoDB 스토리지 엔진은 매우 많은 더티 페이지를 한 번에 기록해야 하는 상황이 옴
  <br><br>

### 4)버퍼 풀 플러시(Buffer Pool Flush)

- MySQL 5.6 버전 까지는 InnoDB 스토리지 더티 페이지 플러시 기능이 그다지 부드럽지 않았음
  - ex) 급작스럽게 디스크 기록이 폭증해서 DB 서버의 사용자 쿼리 처리 성능에 영향을 받음
- MySQL 8.0 이후 대부분의 서비스에서는 더티 페이지를 디스크에 동기화하는 부분에서 디스크 쓰기 폭증 현상은 발생하지 않음
- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음 2가지 플러시 기능을 백그라운드로 실행 1. 플러시 리스트(Flush_list) 플러시 2. LRU 리스트(LRU_list) 플러시
  <br><br>

### 5) 플러시 리스트 플러시

- InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리 사용 공간을 비워야 함 -> 반드시 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화되어야 함
- 이를 위해 주기적으로 `플러시 리스트` 플러시 함수를 호출하여 오래 전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행
- 언제부터 얼마나 많은 더티 페이지를 한 번에 디스크로 기록하느냐에 따라 사용자 쿼리 처리에 영향을 미침

#### InnoDB 스토리지 엔진의 시스템 변수들

- 클리너 스레드(Cleaner Thread)
  - 더티 페이지를 디스크로 동기화하는 스레드
  - `innodb_page_cleaners` 시스템 변수를 통해 클리너 스레드 개수를 조정할 수 있음
  - 여러 개의 InnoDB 버퍼 풀 인스턴스를 동시에 사용할 수 있음
- 버퍼 풀 인스턴스
  - `innodb_buffer_pool_instances` 설정값이 버퍼 풀 인스턴스 개수보다 많은 경우 해당 설정값을 자동으로 변경
  - 시스템 변수 설정값이 버퍼 풀 인스턴스 개수보다 적은 경우 하나의 클리너 스레드가 여러 개의 버퍼 풀 인스턴스를 처리
  - 가능하면 `innodb_page_cleaners` 설정값과 `innodb_buffer_pool_instances` 설정값을 동일하게 설정하는 것이 좋다
    <br><br>

### 6) LRU 리스트 플러시

- InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거하여 새로운 페이지들을 읽어올 공간을 만들어야 함
  - 이 때 `LRU 리스트 플러시 함수`가 사용됨

#### 🔎 동작 원리

1. LRU 리스트의 끝부분부터 시작해 최대 `innodb_lru_scan_depth` 시스템 변수에 설정된 개수만큼 페이지들을 스캔
2. 스캔하면서 더티 페이지는 디스크에 동기화, 클린 페이지는 즉시 `Free List`로 페이지를 옮김
3. 실질적으로 LRU 리스트 스캔은 `(innodb_buffer_pool_instances * innodb_lru_scan_depth)`수만큼 수행
   <br><br>

---

#### Reference

Real MySQL 8.0 (1권)
