# 4.2 InnoDB Storage Engine Architecture - 2

### 7) 버퍼 풀 상태 백업 및 복구

- InnoDB 서버의 버퍼 풀은 쿼리 성능에 매우 밀접하게 연결
  - 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비돼 있기에 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있음
  - 이처럼 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태를 `워밍업(Warming Up)` 이라고 표현

#### 🔎 워밍업

- MySQL 5.5 버전에서는 점검을 위해 서버를 셧다운 했다가 다시 시작하는 경우 서비스 오픈 전에 강제 워밍업
  - 주요 테이블과 인덱스에 대해 풀 스캔을 한 번씩 실행하고 서비스 오픈
- MySQL 5.6 버전부터는 버퍼 풀 덤프 및 적재 기능 도입
  - 서버 점검이나 기타 작업을 위해 서버를 재시작하는 경우 셧다운 전 `innodb_buffer_pool_dump_now` 시스템 변수를 통해 현재 InnoDB 버퍼 풀의 상태를 백업
  - 서버 재시작시 위 시스템 변수를 이용해 백업된 버퍼 풀의 상태를 다시 복구할 수 있음
  - InnoDB 버퍼 풀의 백업은 데이터 디렉터리에 `ib_buffer_pool` 이라는 파일로 생성됨

#### 🔎 ib_buffer_pool 파일

- 아무리 InnoDB 버퍼 풀이 커도 해당 파일은 몇십 MB 이하
- 스토리지 엔진이 버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문. 따라서 버퍼 풀의 백업 속도는 매우 빠름
- 백업된 버퍼 풀의 내용을 다시 버퍼 풀로 복구하는 과정은 버퍼 풀의 크기에 따라 시간이 오래 걸릴 수도 있음
- 버퍼 풀의 백업과 복구 작업은 수동으로 가능하지만, 자동으로 백업된 버퍼 풀의 상태를 복구할 수 있는 기능을 제공함
  <br><br>

### 8) 버퍼 풀의 적재 내용 확인

- MySQL 5.6 버전에서 InnoDB 버퍼 풀의 메모리에 어떤 테이블의 페이지들이 적재돼 있는지 확인 가능
  - 버퍼 풀이 큰 경우 테이블 조회가 큰 부하를 일으켜 서비스 쿼리가 많이 느려짐
  - 따라서 실제 서비스용으로 사용되는 DB 서버에서는 버퍼 풀의 상태를 확인하는 것이 거의 불가능
- MySQL 8.0 버전에서 이러한 문제 해결을 위해 `information_schema` 데이터베이스에 `innodb_cached_indexes` 테이블이 추가
  - 해당 테이블을 이용하면 테이블의 인덱스 별로 데이터 페이지가 얼마나 버퍼 풀에 적재돼 있는지 확인할 수 있음
    <br><br>

## 4.2.8 Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간 낭비를 막기 위해 페이지의 변경된 내용만 기록
  - 따라서 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 생기면 해당 페이지의 내용은 복구하지 못할 수도 있음
  - 위처럼 페이지 일부만 기록되는 현상을 `파셜 페이지(Partial-Page)` 또는 `톤 페이지(Torn-Page)` 라고 함 -> 하드웨어 오작동이나 시스템 비정상 종료 등으로 발생 가능
- 위 문제를 막기 위해 InnoDB 스토리지 엔진에서는 `Double-Write` 기법을 이용
  <br><br>

### 🔎 Double-Write 작동 방식

![image](https://github.com/100-hours-a-week/5-jun2-java-casino/assets/98972385/fd56242b-3641-4c0d-bda2-ada1a0f772bd)

- InnoDB에서 'A' ~ 'E'까지 더티 페이지를 디스크로 플러시한다고 가정

1. 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전에 'A' ~ 'E'까지의 더티 페이지를 묶어 한 번의 디스크 쓰기로 시스템 테이블 스페이스의 DoubleWrite 버퍼에 기록
2. 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행
3. DoubleWrite 버퍼 공간에 기록된 변경 내용은 실제 데이터 파일에 'A' ~ 'E' 더티 페이지가 정상적으로 기록되면 더이상 필요 없어짐
4. DoubleWrite 버퍼의 내용은 실제 데이터 파일의 쓰기가 중간에 실패할 때만 원래 목적으로 사용됨
   <br><br>

## 4.2.9 언두 로그

- `언두 로그(Undo Log)` : InnoDB 스토리지 엔진이 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업, 이때 백업된 데이터를 말함

#### 🔎 언두 로그가 어떻게 사용되는가?

1. 트랜잭션 보장
   - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 함
   - 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구
2. 격리 수준 보장
   - 특정 커넥션에서 데이터를 변경하는 도중에 다른 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고, 언두 로그에 백업해둔 데이터를 읽어서 반환
     <br><br>

### 1) 언두 로그 레코드 모니터링

```sql
UPDATE member SET name='홍길동' WHERE member_id=1;
```

- 위처럼 업데이트 문장을 실행했다고 가정

1. 트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 '홍길동'으로 변경
2. 변경되기 전의 값이 '광개토'라면, 언두 영역에는 '광개토'라는 값이 백업됨
3. 해당 상태에서 사용자가 커밋하면 현재 상태가 그대로 유지되고, 롤백하면 언두 영역의 백업 데이터를 다시 데이터 파일로 복구

#### 🔎 언두 로그 데이터의 용도

1. 트랜잭션의 롤백 대비용
2. 트랜잭션의 격리 수준을 유지하며 높은 동시성을 제공 - `격리 수준` : 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때, 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보일지를 결정하는 기준
   <br><br>

#### 🔎 MySQL 8.0 이상 언두 로그

- 기존 MySQL 5.5 버전까지는 언두 로그의 사용 공간이 한 번 늘어나면 서버를 새로 구축하지 않는 한 줄일 수 없음
  - 언두 로그가 늘어나면 디스크 사용량뿐만 아니라, 매번 백업할 때도 그만큼 더 복사해야하는 문제점 발생
- MySQL 5.7, MySQL 8.0에서는 언두 로그 공간의 문제점 해결
  - 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄이는 것도 가능
  - MySQL 서버가 필요한 시점에 사용 공간을 자동으로 줄이는 것도 가능
    <br>

```sql
SHOW ENGINE INNODB STATUS \G
```

- 위 명령어를 통해 MySQL 서버의 언두 로그 레코드 건수를 확인할 수 있음
  <br><br>

### 2) 언두 테이블스페이스 관리

- `언두 테이블스페이스(Undo Tablespace)` : 언두 로그가 저장되는 공간
- MySQL 8.0 이상부터 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록되도록 개선
  <br><br>

#### 🔎 언두 테이블스페이스 구조

![image](https://github.com/100-hours-a-week/5-jun2-java-casino/assets/98972385/f6f5f99a-7e2b-4878-98fc-385426ef80f0)
<br>

- 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가짐
- 롤백 세그먼트는 1개 이상의 언두 슬롯(Undo Slot)을 가짐
  - InnoDB 페이지 크기를 16byte로 나눈 값의 개수만큼의 언두 슬롯을 가짐
- `최대 동시 트랜잭션 수` = (InnoDB 페이지 크기) / 16 _ (롤백 세그먼트 개수) _ (언두 테이블스페이스 개수)
  <br><br>

```sql
CREATE UNDO TABLESPACE;
DROP TABLESPACE;
```

- 새로운 언두 테이블을 동적으로 추가/삭제 가능
  <br><br>

#### 🔎 Undo tablespace truncate

- `Undo tablespace truncate` : 언두 테이블스페이스 공간을 필요한 만큼만 남기고, 불필요하거나 과도하게 할당된 공간을 OS로 반납하는 것
- 자동과 수동 두 가지 방법이 존재, MySQL 8.0부터 지원
  <br>

1. `자동 모드` : 트랜잭션이 데이터를 변경하면 이전 버전의 데이터를 언두 로그로 기록하는데, 트랜잭션 커밋시 언두 로그에 복사된 이전 값은 불필요
   - InnoDB 스토리지 엔진의 `퍼지 스레드(Purge Thread)`는 주기적으로 언두 로그 공간에서 불필요해진 언두 로그를 삭제하는 작업 실행
   - 위 작업을 `언두 퍼지(Undo Purge)` 라고 함
2. `수동 모드` : `innodb_undo_log_truncate` 시스템 변수가 OFF로 설정되어, 언두 로그 파일의 잘라내기가 자동으로 실행되지 않거나 예상보다 자동 모드로 언두 테이블스페이스의 공간 반납이 부진한 경우 사용 - 언두 테이블스페이스가 최소 3개 이상은 돼야 작동함
   <br><br>

## 4.2.10 체인지 버퍼

- RDBMS에서 레코드가 INSERT/UPDATE 될 때는 데이터 파일 변경 작업 뿐만 아니라, 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요
- 해당 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 상당히 많은 자원을 소모
- `체인지 버퍼(ChangeBuffer)` : InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행. 만약 디스크로부터 읽어와 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환. 이 때 사용하는 임시 메모리 공간을 말함
  <br><br>

## 4.2.11 리두 로그 및 로그 버퍼

### 1) 리두 로그 아카이빙

### 2) 리두 로그 활성화 및 비활성화

<br><br>

## 4.2.12 어댑티브 해시 인덱스
