# 4.2 InnoDB Storage Engine Architecture

![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/00c7eeca-416a-4c71-a3bb-e588956032c2)

- InnoDB 는 MySQL에서 가장 많이 사용되는 스토리지 엔진
- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공
  - 높은 동시성 처리 가능
  - 안정적이며 성능이 뛰어남
    <br><br>

## 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장 (PK 값의 순서대로 디스크에 저장)
- 모든 세컨더리 인덱스는 레코드 주소 대신 PK 값을 논리적인 주소로 사용
- 쿼리 실행 계획에서 다른 보조 인덱스에 비해 PK 비중이 높게 설정
- MyISAM 스토리지 엔진에서는 클러스터링 키 미지원
  - PK 는 유니크 제약을 가진 세컨더리 인덱스
  - 모든 인덱스는 물리적인 레코드 주소 값 (ROWID)을 가짐
    <br><br>

## 4.2.2 외래 키 지원

- 외래 키 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능 (MyISAM 이나 MEMORY 테이블에선 사용 불가)
- FK는 부모 및 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요, 변경 시 반드시 부모 및 자식 테이블 데이터 존재 여부 체크 작업 필요
  - 잠금이 여러 테이블로 전파 => 데드락 발생 가능성 증가
- FK 가 복잡하게 얽힌 경우 수동으로 데이터를 적재하거나 스키마 변경 등 관리 작업 실패 가능
  - `foreign_key_checks` 시스템 변수를 `OFF` 로 설정하면 FK 관계에 대한 체크 작업을 일시적으로 멈출 수 있음
    <br><br>

## 4.2.3 MVCC (Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것
  - `언두 로그(Undo log)` 를 통해 구현
- 멀티 버전 => 하나의 레코드에 대해 여러 개 버전이 동시에 관리된다는 의미

### 🔎 InnoDB 스토리지 사용 테이블 데이터 변경 처리

```sql
CREATE TABLE member {
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(20) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
};

INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

COMMIT;
```

- 위 명령어를 입력했을 때 데이터베이스의 상태
  <br>
  ![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/a8631013-da65-47d5-a9bc-81553ab9460e)
  <br><br>

- 업데이트 쿼리

```sql
UPDATE member SET m_area='경기' WHERE m_id=12;
```

![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/c5ba6df2-f3c4-406b-8037-52f5b5f852dc)

- COMMIT 이나 ROLLBACK 되지 않은 상태에서 다른 사용자가 `SELECT` 쿼리로 작업 중인 레코드를 조회한다면?
  - MySQL 서버의 시스템 변수에 설정된 격리 수준에 따라 결과가 달라짐
    1. 격리 수준이 `READ_UNCOMMITTED` 인 경우 : InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환
    2. 격리 수준이 `READ_COMMITTED` 나 그 이상인 경우 : InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환
- 위 과정을 DBMS에서 `MVCC`라고 표현
  - 여러 개의 버전이 유지되며, 필요에 따라, 상황에 따라 보여지는 데이터가 달라지는 구조
    <br><br>

## 4.2.4 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 통해 잠금을 걸지 않고 읽기 작업을 수행
- 다른 트랜잭션이 가진 잠금을 기다리지 않고 읽기 작업 가능

### 💡 예시

![image](https://github.com/junseoparkk/discord-bot-tutorial/assets/98972385/1622cc7f-101b-4fac-9990-a5fd4557ab4c)

- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도, 해당 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음 => `잠금 없는 일관된 읽기`
- InnoDB 에선 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용
  <br><br>

## 4.2.5 자동 데드락 감지

- 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 `그래프(Wait-for List)`형태로 관리
- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어, 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그중 하나를 강제 종료
  - 트랜잭션 종료 순서를 판단하는 기준 : 트랜잭션의 언두 로그 양
  - 일반적으로 언두 로그 레코드를 더 적게 가진 트랜잭션이 롤백의 대상이 됨 - 롤백을 해도 언두 처리를 해야 할 내용이 적다는 의미 => 서버 부하도 덜 유발함
    <br><br>

### 🔎 데드락 감지 스레드 작업 성능

- 일반적인 서비스에선 데드락 감지 스레드가 트랜잭션 잠금 목록을 검사해 데드락을 찾는 작업은 크게 부담되지 않음
- 동시 처리 스레드가 매우 많아지거나, 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐
  - 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음
  - 데드락 감지 스레드가 느려지면, 서비스 쿼리를 처리하는 스레드의 작업도 대기하게 됨 => 악영향
- 이런 문제를 해결하기 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수 제거
  - OFF 로 설정하면 데드락 감지 스레드 작동 X
  - 데드락 감지 스레드가 작동하지 않으면 InnoDB 스토리지 엔진 내부에서 2개 이상의 트랜잭션이 데드락 상황이 발생해도 중재 기능이 없어 무한정 대기

## 4.2.6 자동화된 장애 복구

- InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘 탑재
  - MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나, 일부 디스크에만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행 됨
    <br><br>

### 🔎 디스크나 서버 HW 이슈로 자동 복구를 못할 경우

- MySQL 서버의 설정 파일에 `innodb_force_recovery` 시스템 변수를 설정하여 MySQL 서버를 시작해야 함
- 서버 시작히 InnoDB 스토리지 엔진이 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행할 수 있게 함
  - InnoDB 로그 파일이 손상됐다면 6으로 설정하고 서버 가동
  - InnoDB 테이블의 데이터 파일이 손상됐다면 1로 설정하고 서버 가동
  - 어떤 부분이 문제인지 알 수 없다면 시스템 변수 값을 1~6까지 변경하면서 서버를 재시작 해 본다.
    <br><br>

### 🔎 `inoodb_force_recovery` 설정 값

- `1 (SRV_FORCE_IGNORE_CORRUPT)`
  - InnoDB 테이블 스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 서버를 시작
  - mysqldump 프로그램 등을 통해 덤프해서 DB를 다시 구축하는 것이 좋다
- `2 (SRV_FORCE_NO_BACKGROUND)`
  - 백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 서브를 시작
  - 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 해당 모드로 복구
- `3 (SRV_FORCE_NO_TRX_UNDO)`
  - InnoDB에서 트랜잭션 실행시 롤백에 대비해 변경 전 데이터를 언두 영역에 기록
  - 커밋되지 않고 종료된 트랜잭션은 계쏙 그 상태로 남아 있게 서버를 시작하는 모드
  - 우선 서버가 시작되면 mysqldump 를 이용해 데이터를 백업하여 다시 DB를 추축하는 것이 좋다
- `4 (SRV_FORCE_NO_IBUF_MERGE)`
  - InnoDB 는 INSERT, UPDATE, DELETE 등의 데이터 변경으로 인한 인덱스 변경 작업을 상황에 따라 다르게 처리
    - 즉시 처리
    - 인서트 버퍼에 저장해두고 나중에 처리
  - 인서트 버퍼에 기록된 내용은 언제 데이터 파일에 병합될지 알 수 없음 (MySQL을 종료해도 병합되지 않을 수 있음) => 인서트 버퍼 손상시 서버 시작 불가능
  - 해당 모드는 InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 서버를 실행함
- `5 (SRV_FORCE_NO_UNDO_LOG_SCAN)`
  - MySQL 서버가 장애나 정상 종료되는 시점에 진행 중인 트랜잭션이 있다면 해당 커넥션을 강제로 끊고, 별도의 정리 작업 없이 종료
  - 다시 시작하면 언두 레코드를 이용해 데이터 페이지를 복구하고, 리두 로그를 적용해 종료 및 장애 발생 시점의 상태를 재현함
  - 마지막으로 커밋되지 않은 트랜잭션에서 변경한 작업은 모두 롤백 처리 함
  - InnoDB의 언두 로그를 사용할 수 없다면 에러가 발생하며 서버 시작 불가능
  - 해당 모드는 언두 로그를 모두 무시하고 MySQL을 시작
    - 해당 모드로 복구되면 서버 종료 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리 (실제로 잘못된 데이터가 DB에 남는 것)
    - mysqldump 를 이용해 데이터를 백업, DB를 새로 구축해야 함
- `6 (SRV_FORCE_NO_LOG_REDO)`
  - InnoDB 스토리지 엔진의 리두 로그가 손상되면 서버 시작 불가능
  - 해당 복구 모드로 시작하면 리두 로그를 모두 무시하고 서버 시작
  - 마지막 체크포인트 시점의 데이터만 남게 됨
    - 기존 InnoDB의 리두 로그는 모두 삭제하고 서버를 시작하는 것이 좋음
    - mysqldump를 이용해 데이터를 모두 백업하고 새로운 서버를 구축하는 것이 좋음
