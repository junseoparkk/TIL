# <font color="#d99694">9.1 개요</font>

## 9.1.1 쿼리 실행 절차

### MySQL 서버에서 쿼리가 실행되는 과정
1. 서버로부터 요청된 SQL문을 쪼개 서버가 이해할 수 있는 수준으로 분리(파스 트리)
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
3. 2. 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴

#### 1) 첫 번째 단계 (SQL 파싱)
- MySQL 서버의 *SQL Parser* 라는 모듈로 처리
- 만약 SQL 문장이 문법적 오류가 있다면 해당 단계에서 걸러짐
- *SQL 파스 트리* 가 만들어지는 단계
	- MySQL 서버는 문장 자체가 아니라 파스 트리를 이용해 쿼리를 실행

#### 2) 두 번째 단계 (최적화 및 실행 계획 수립)
- MySQL 서버의 *Optimizer* 에서 처리
- 불필요한 조건 제거 및 복잡한 연산 단순화
- 여러 테이블의 조인이 있는 경우 테이블 읽는 순서를 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이요해 사용할 인덱스 결정
- 가져온 레코드들은 임시 테이블에 넣고 가공해야 하는지 결정

#### 3) 세 번째 단계
- 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
- MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인 or 정렬하는 작업 수행

> [!NOTE]
> 첫 번째, 두 번째 단계는 거의 MySQL 엔진에서 처리, 세 번째 단계는 MySQL 엔진 + 스토리지 엔진이 동시에 참여하여 처리


## 9.1.2 옵티마이저의 종류

### 옵티마이저?
- 데이터베이스 서버에서 두뇌와 같은 역할
- 예전 초기 버전의 오라클 DBMS에서 많이 사용한 *규칙 기반 최적화(Rule-based optimizer, RBO)* 방법
- 현재 대부분의 DBMS가 선택하고 있는 *비용 기반 최적화(Cost-based optimizer, CBO)* 방법

#### 1) 규칙 기반 최적화
- 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
- 통계 정보(테이블 레코드 건수, 컬럼값 분포도 등)를 조사하지 않고 실행 계획 수립 -> 같은 쿼리에 대해서 거의 항상 같은 실행 방법 생성
- 사용자 데이터는 분포도가 매우 다양하기 때문에 해당 방식은 오래전부터 거의 사용되지 않음

#### 2) 비용 기반 최적화
- 쿼리를 처리하기 위한 여러 가지 가능한 방법 생성
- 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
- 이렇게 산출된 실행 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행

> [!NOTE]
> 규칙 기반 최적화는 각 테이블이나 인덱스의 통계 정보가 거의 없고 상대적으로 느린 CPU 연산 탓에 비용 계산 과정이 부담스럽다는 이유로 사용되던 최적화 방법. 따라서 현재는 대부분 RDBMS가 비용 기반의 옵티마이저를 채택

---

# <font color="#d99694">9.2 기본 데이터 처리</font>

## 9.2.1 풀 테이블 스캔 & 풀 인덱스 스캔

*풀 테이블 스캔 (Full Table Scan)* : 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업

### 풀 테이블 스캔 선택 조건
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우 (일반적으로 테이블 1개의 페이지로 구성된 경우)
- `WHERE` 절이나 `ON` 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- *인덱스 레인지 스캔* 을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드가 너무 많은 경우 (인덱스의 B-Tree를 샘플링해서 조사한 통계 정보 기준)

### 풀 테이블 스캔시 디스크로부터 페이지를 하나씩 읽어올까?
- 일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 큼 -> 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요
- 대부분 DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능 내장
- MySQL에는 풀 테이블 스캔시 한꺼번에 몇 개씩 페이지를 읽어올지 설정하는 시스템 변수 존재 X
- 따라서 *MyISAM* 스토리지 엔진에서는 맞는 이야기, *InnoDB* 에서는 틀린 말!

#### InnoDB 스토리지 엔진 & 리드 어헤드
- 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 *리드 어헤드(Read ahead)* 작업이 자동으로 시작됨
- *리드 어헤드* : 어떤 영역의 데이터가 앞으로 필요할 것을 예측하여 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
	- 풀 테이블 스캔뿐만 아니라 풀 인덱스 스캔에서도 동일하게 사용됨
- 풀 테이블 스캔이 실행되면 처음 몇 개의 데이터 페이지는 `포그라운드 스레드` 가 페이지 읽기를 실행
	- 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘긴다
	- 백그라운드가 넘겨받는 시점부터 한 번에 4개 or 8개씩 페이지를 읽으면서 그 수를 증가시킴
	- 한 번에 64개의 데이터 페이지까지 읽어서 버퍼 풀에 저장해 둠

#### innodb_read_ahead_threshold 시스템 변수
- 해당 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값 설정 가능
- 포그라운드 스레드에 의해 `innodb_read_ahead_threshold` 시스템 변수에 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 백그라운드 스레드를 이용해 대량으로 그다음 페이지를 읽어 버퍼 풀로 적재

#### 예시
```mysql
SELECT COUNT(*) FROM employees;
```
- 위 쿼리는 조건 없이 테이블 레코드 건수를 조회하므로 `풀 테이블 스캔` 을 할 것처럼 보임
- 실제 실행 계획은 `풀 인덱스 스캔` 을 할 가능성이 높음
	- 단순히 레코드 건수만 필요한 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문
	- 일반적으로 인덱스는 테이블의 2~3개 컬럼만으로 구성 -> 테이블 자체보다 용량이 작아 처리가 빠름


```mysql
SELECT * FROM employees;
```
- 위 퀴리처럼 레코드에만 있는 컬럼이 필요한 경우 풀 인덱스 스캔을 활용하지 못하고 풀 테이블 스캔 선택

## 9.2.2 병렬 처리

> 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리하는 것을 의미

#### 여러 개의 스레드를 이용할 수 있는가?
```mysql
SET SESSION innodb_parallel_read_threads=1;
SELECT COUNT(*) FROM salaries;

SET SESSION innodb_parallel_read_threads=2;
SELECT COUNT(*) FROM salaries;

SET SESSION innodb_parallel_read_threads=4;
SELECT COUNT(*) FROM salaries;
```
- `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 설정할 수 있음
- 현재 MySQL 서버에서는 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 X
- 위처럼 조건 없이 단순히 테이블 전체 건수를 가져오는 쿼리만 병렬로 처리 가능
- 병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU 코어 개수를 넘어서는 경우 성능이 떨어질 수도 있음

## 9.2.3 ORDER BY 처리 (Using filesort)

> 레코드 1~2 건을 가져오는 쿼리를 제외하면 대부분 SELECT 쿼리에서 정렬은 필수적으로 사용됨
> 정렬을 처리하는 방법엔 "인덱스"를 이용하는 방법, "Filesort"라는 별도의 처리를 이용하는 방법 존재

![image](https://github.com/user-attachments/assets/8b8ea61e-b375-4f00-b258-d2d202ebb777)


#### 모든 정렬을 인덱스를 이용하도록 튜닝하기 어려운 경우
- 정렬 기준이 너무 많아 요건별로 인덱스를 생성하는 것이 어려운 경우
- `GROUP BY` 의 결과 또는 `DISTINCT` 같은 처리의 결과를 정렬해야 하는 경우
- `UNION` 의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우
---
### 9.2.3.1 소트 버퍼 (Sort Buffer)

*Sort Buffer* : MySQL에서 정렬을 수행하기 위해 할당받아서 사용하는 별도의 메모리 공간
- 정렬이 필요한 경우에만 할당
- 버퍼의 크기는 정렬해야 하는 레코드 크기에 따라 가변적으로 증가
- 최대 사용 가능한 소트 버퍼 공간은 `sort_buffer_size` 시스템 변수로 설정 가능
- 소트 버퍼를 위한 메모리 공간은 쿼리 실행이 완료되면 즉시 시스템으로 반납

#### 문제 상황
> 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면?

- MySQL은 정렬해야 할 레코드를 여러 조각으로 나눠서 처리 -> 임시 저장을 위해 디스크 사용
  1. 메모리의 소트 버퍼에서 정렬을 수행, 결과를 임시로 디스크에 기록
  2. 다음 레코드를 가져와서 다시 정렬하여 반복적으로 디스크에 임시 저장
- *멀티 머지 (Multi-merge)* : 정렬 수행시 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하는 작업

- 위 작업들은 모두 디스크 쓰기/읽기를 유발, 레코드 건수가 많을수록 반복 작업 횟수가 증가
- 소트 버퍼 크기를 크게 설정하면 디스크를 사용하지 않을까? -> Nop!
- 아래 결과를 보면 특정 사이즈 이상부터 시간 단축 효과 X

![image](https://github.com/user-attachments/assets/f628375a-e3a0-49cd-a800-b9ab263aade0)


#### 소트 버퍼 메모리 영역
- 소트 버퍼는 *세션(로컬) 메모리 영역*에 해당됨
- 즉, 여러 클라이언트가 공유해서 사용할 수 있는 영역이 아님
- 커넥션이 많으면 많을수록,  정렬 작업이 많으면 많을수록 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미
- 따라서 소트 버퍼의 크기를 `10MB` 이상으로 설정하면 대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시에 실행되면서 OS는 메모리 부족 현상을 겪을 수 있음
---
### 9.2.3.2 정렬 알고리즘

- 레코드 정렬시 레코드 전체를 소트 버퍼에 담을지 or 정렬 기준 컬럼만 담을지에 따라 정렬 모드가 나뉨
	- 싱글 패스 (Single-pass)
	- 투 패스 (Two-pass)

#### 정렬 방식
1. `<sort_key, rowid>`  : 정렬 키와 레코드의 *Row ID* 만 가져와서 정렬하는 방식 -> *투 패스*
2. `<sort_key, additional_fields` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식 (레코드 컬럼들은 고정 사이즈로 메모리에 저장) -> *싱글 패스*
3. `<sort_key, packed_additional_fields` : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식 (레코드 컬럼들은 가변 사이즈로 메모리에 저장) -> *싱글 패스*

#### 9.2.3.2.1 싱글 패스 정렬 방식
- 소트 버퍼에 정렬 기준 컬럼을 포함해 `SELECT` 대상이 되는 컬럼 전부를 담아 정렬을 수행하는 정렬 방식

```mysql
SELECT emp_no, first_name, last_name 
FROM employees
ORDER BY first_name;
```
![image](https://github.com/user-attachments/assets/449c6ac5-deb3-4538-a83f-5f82e9dcada8)


#### 9.2.3.2.2 투 패스 정렬 방식
- 정렬 대상 컬럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행, 정렬된 순서대로 다시 PK로 테이블을 읽어 `SELECT` 할 컬럼을 가져오는 정렬 방식
- 싱글 패스 정렬 방식이 도입되기 이전부터 사용됨

![image](https://github.com/user-attachments/assets/f5c824bc-5b0e-4fdf-a202-2533fa97865d)


#### 싱글 패스 vs 투 패스
- 투 패스 방식은 테이블을 두 번 읽어야 하므로 불합리하지 -> 싱글 패스 방식은 이러한 불합리가 없음
- 싱글 패스 방식은 더 많은 소트 버퍼 공간이 필요
- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용함
- 다음 경우에 보통 투 패스 방식을 사용
	- 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
	- `BLOB` 이나 `TEXT` 타입의 컬럼이 `SELECT` 대상에 포함될 때
*여까지*
---
### 9.2.3.3 정렬 처리 방법

![image](https://github.com/user-attachments/assets/430d1a27-2581-445e-bd05-4fe515731e05)

- 쿼리에 `ORDER BY` 가 사용되면 반드시 위 3가지 처리 방법 중 하나로 정렬이 처리됨
- 아래쪽에 있는 정렬 방법일수록 처리 속도는 떨어짐

#### 9.2.3.3.1 인덱스를 이용한 정렬
- 반드시 `ORDER BY` 에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, `ORDER BY` 의 순서대로 생성된 인덱스가 있어야 함
- `WHERE` 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면, 그 조건과 `ORDER BY` 는 같은 인덱스를 사용할 수 있어야 함
- `B-Tree` 계열의 인덱스가 아닌 해시 인덱스, 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬 사용 불가
	- 예외적으로 `R-Tree` 는 `B-Tree` 계열이지만, 특성상 사용 불가

![image](https://github.com/user-attachments/assets/79111298-6189-49b5-bc82-5ff41476486d)

- 인덱스를 이용한 정렬에선 실제 인덱스 값이 정렬돼 있기 때문에 인덱스 순서대로 읽기만 하면 됨
- 실제로 MySQL 엔진에서도 별도의 정렬을 위한 추가 작업 수행 X
- `ORDER BY` 절이 없어도 `employees` 테이블의 PK를 읽고, `salaries` 테이블을 조인하여 정렬이 됨

#### 9.2.3.3.2 Join의 드라이빙 테이블만 연결
- 일반적으로 조인 수행시 첫 번째 테이블의 레코드를 먼저 정렬한 뒤 조인을 실행하는 것이 정렬의 차선책이 됨
- 조인에서 첫 번째로 읽히는 테이블 (드라이빙 테이블) 의 컬럼만으로 `ORDER BY` 절을 작성해야 함


```mysql
SELECT *
FROM employees e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp.no BETWEEN 100002 AND 100010
ORDER BY e.last_name;
```
- 위 2가지 `WHERE` 조건때문에 옵티마이저는 `employees` 테이블을 드라이빙 테이블로 선택
	- `WHERE` 절의 검색 조건은 `employees` 테이블의 PK를 이용해 검색하면 작업량을 줄일 수 있음
	- 드리븐 테이블의 조인 컬럼인 `emp_no` 컬럼에 인덱스가 있음

![image](https://github.com/user-attachments/assets/4a62f47a-89a3-4ca4-a28d-8fdffde1e873)

- 조인의 첫 번째 테이블 (드라이빙 테이블)만 정렬 실행
1. 인덱스를 이용해 `emp_no BETWEEN 100001 AND 100010` 조건을 만족하는 9건 검색
2. 검색 결과를 `last_name` 컬럼으로 정렬 수행 (Filesort)
3. 정렬된 결과를 순서대로 읽으며 `salaries` 테이블과 조인을 수행해 86건의 최종 결과를 가져옴

#### 9.2.3.3.3 임시 테이블을 이용한 정렬
- 정렬의 3가지 방법중 정렬해야 할 레코드 건수가 가장 많기 때문에 가장 느린 방법
- 쿼리가 여러 테이블을 조인하지 않고, 하나의 테이블로부터 `SELECT` 해서 정렬하는 경우라면 임시 테이블 필요 X
- 하지만 2개 이상의 테이블을 조인하여 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있음


```mysql
SELECT *
FROM employee e, salaries s
WHERE s.emp_no=e.emp_no
AND e.emp_no BETWEEN 100002 AND 100010
ORDER BY s.salary;
```
- `ORDER BY` 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블 (salaries) 에 있는 컬럼
- 정렬이 수행되기 전에 `salaries` 테이블을 읽어야 하므로 조인된 데이터를 가지고 정렬해야 함

![image](https://github.com/user-attachments/assets/9737cd9a-d989-4564-87e2-ffb909ecc2b1)

- 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 처리함

#### 9.2.3.3.4 정렬 처리 방법의 성능 비교
- 주로 웹 서비스용 쿼리에서는 `ORDER BY` 와 함께 `LIMIT` 이 거의 필수로 사용되는 경향이 있음. 이는 서버가 처리해야 할 작업량을 줄이는 역할
- `ORDER BY` , `GROUP BY` 같은 작업은 `WHERE` 조건을 만족하는 레코드를 `LIMIT` 만큼 가져와서 처리할 수 없음 -> 우선 조건을 만족하는 레코들르 전부 가져와 정렬을 수행 or 그루핑 작업을 실행해야 `LIMIT` 으로 건수 제한 가능
- 쿼리가 처리되는 방법을 *스트리밍 처리*, *버퍼링 처리* 로 구분

##### 9.2.3.3.4.1 스트리밍 방식
- 서버 쪽에서 처리할 데이터가 얼마인지에 관계 없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
- 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번쩨 레코드를 전달 받음

##### 9.2.3.3.4.2 버퍼링 방식
- 모든 레코드를 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느림 -> 스트리밍의 반대 방식

#### 예시
```mysql
SELECT *
FROM tb_test1 t1, tb_test2 t2
WHERE t1.col1=t2.col1
ORDER BY t1.col2
LIMIT 10;
```

- `tb_test1` 이 드라이빙되는 경우
![image](https://github.com/user-attachments/assets/77811ac4-eb2c-48a5-a6d7-e4b5e6c32846)


- `tb_test2` 가 드라이빙되는 경우
![image](https://github.com/user-attachments/assets/1d144421-ab24-48d7-80bb-9b23710d6fc8)


## 9.2.4 GROUP BY 처리

> GROUP BY 또한 ORDER BY 와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나
> GROUP BY 에 사용된 조건은 인덱스를 사용해서 처리 불가 -> HAVING절 튜닝을 위해 인덱스 생성할 필요 X

1. 인덱스를 사용하는 경우
   - 인덱스 스캔 : 인덱스를 차례대로 읽는 방법
   - 루스 인덱스 스캔 : 인덱스를 건너뛰면서 읽는 방법
2. 인덱스를 사용하지 못하는 경우
   - 임시 테이블 사용
